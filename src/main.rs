// pub mod tiles;
// use crate::tiles::Tile;

use std::collections::HashMap;

const NUMBER_TILES: [&str; 9] = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
const WIND_TILES: [&str; 4] = ["E", "S", "W", "N"];
const DRAGON_TILES: [&str; 3] = ["G", "R", "W"];
// const TILE_SUITS: [&str; 5] = ["m", "p", "s", "w", "d"];
const HONOR_SUITS: [&str; 2] = ["w", "d"];
const NUMBER_SUITS: [&str; 3] = ["m", "p", "s"];

// fn check_valid_tile_string(tile_str: &String) {
//     assert!(tile_str.len() == 2);
//     let tile_rank = tile_str.get(0..1).expect("Expected tile rank");
//     let tile_suit = tile_str.get(1..2).expect("Expected tile suit");
//     assert!(
//         NUMBER_TILES.contains(&tile_rank)
//             || WIND_TILES.contains(&tile_rank)
//             || DRAGON_TILES.contains(&tile_rank)
//     );
//     assert!(TILE_SUITS.contains(&tile_suit));
// }

fn count_tiles_by_suit_rank(tiles: &Vec<String>) -> HashMap<&str, HashMap<&str, i32>> {
    // build frequency count per tile suit: mapping of tile suit -> (mapping of rank -> count)
    let mut tile_counts_by_suit: HashMap<&str, HashMap<&str, i32>> = HashMap::new();
    /* section generated by ChatGPT Mar 23 version:
     * prompt:
     * Write a program in Rust that takes in a Vector<String> where each element is a 2-character ASCII string,
     * and returns a HashMap<&str, HashMap<&str, i32>> that contains the counts of each (first character, second
     * character) pair in the input Vector, grouped by the outer key.
     * Example input: [String::from("a1"), String::from("a1"), String::from("a2"), String::from("b2")]
     * Example output: {"a": {"1": 2, "2": 1}, "b": {"2": 1}}
     */
    for s in tiles.iter() {
        let (tile_rank, tile_suit) = s.split_at(1);
        let inner_map = tile_counts_by_suit
            .entry(tile_suit)
            .or_insert_with(HashMap::new);
        *inner_map.entry(tile_rank).or_insert(0) += 1;
    }
    // end section generated by ChatGPT

    // prior attempts to build the tile_counts_by_suit nested map
    // for tile_str in tiles {
    //     let tile_rank = tile_str.get(0..1).expect("Expected tile rank");
    //     let tile_suit = tile_str.get(1..2).expect("Expected tile suit");

    //     // if-else on contains_key (can also use if-left to initialize suit_counts in if block)
    //     if tile_counts_by_suit.contains_key(&tile_suit) {
    //         let suit_counts = tile_counts_by_suit.get_mut(&tile_suit).unwrap();
    //         let count = suit_counts.entry(tile_rank).or_insert(0);
    //         *count += 1;
    //     } else {
    //         let mut empty_counts = HashMap::new();
    //         // we have to update/mutate `empty_counts` before we call `tile_counts_by_suit.insert(...)`,
    //         //  as that insert will transfer ownership of `empty_counts`
    //         empty_counts.insert(tile_rank, 1);
    //         tile_counts_by_suit.insert(tile_suit, empty_counts);
    //     }
    // }

    tile_counts_by_suit
}

fn is_thirteen_orphans_yaku(tile_counts_by_suit: &HashMap<&str, HashMap<&str, i32>>) -> bool {
    // Returns true iff the hand is a winning hand by the thirteen orphans yaku (aka "kokushi musou", or just "kokushi")
    let mut paired_tile = String::from("");

    // check winds:
    match tile_counts_by_suit.get("w") {
        Some(wind_counts) => {
            for wind_tile in WIND_TILES {
                let count = wind_counts.get(wind_tile).unwrap_or(&0);
                let count = *count;
                if count > 2 {
                    return false;
                } else if count == 2 {
                    // exactly one of the "orphans" (terminal number tiles and honor tiles)
                    // must be paired in thirteen orphans yaku
                    if paired_tile.is_empty() {
                        paired_tile.push_str(wind_tile);
                        paired_tile.push_str("w");
                        continue;
                    } else {
                        return false;
                    }
                }
            }
        }
        // no winds entirely disqualifies the hand from thirteen orphans yaku
        None => return false,
    };

    // check dragons:
    match tile_counts_by_suit.get("d") {
        Some(dragon_counts) => {
            for dragon_tile in DRAGON_TILES {
                let count = dragon_counts.get(dragon_tile).unwrap_or(&0);
                let count = *count;
                if count > 2 {
                    return false;
                } else if count == 2 {
                    // exactly one of the "orphans" (terminal number tiles and honor tiles)
                    // must be paired in thirteen orphans yaku
                    if paired_tile.is_empty() {
                        paired_tile.push_str(dragon_tile);
                        paired_tile.push_str("w");
                        continue;
                    } else {
                        return false;
                    }
                }
            }
        }
        // no dragons entirely disqualifies the hand from thirteen orphans yaku
        None => return false,
    };

    // check number suits:
    for tile_suit in NUMBER_SUITS {
        match tile_counts_by_suit.get(tile_suit) {
            Some(tile_counts) => {
                for tile_rank in NUMBER_TILES {
                    let count = tile_counts.get(tile_rank).unwrap_or(&0);
                    let count = *count;
                    if tile_rank == "1" || tile_rank == "9" {
                        if count > 2 {
                            return false;
                        } else if count == 2 {
                            // exactly one of the "orphans" (terminal number tiles and honor tiles)
                            // must be paired in thirteen orphans yaku
                            if paired_tile.is_empty() {
                                paired_tile.push_str(tile_rank);
                                paired_tile.push_str(tile_suit);
                                continue;
                            } else {
                                return false;
                            }
                        }
                    } else if count > 0 {
                        // any non-terminal number tiles (i.e. not 1 or 9) tiles immediately disqualifies the hand from thirteen orphans yaku
                        return false;
                    }
                }
            }
            // missing a number suit entirely disqualifies the hand from thirteen orphans yaku
            None => return false,
        };
    }

    // at the end, there still must be a single paired tile
    return !paired_tile.is_empty();
}

fn is_seven_pairs_yaku(tile_counts_by_suit: &HashMap<&str, HashMap<&str, i32>>) -> bool {
    // Returns true iff the hand is a winning hand by the seven pairs yaku (aka "chiitoitsu", "chiitoi", "niconico")
    // Note: does not allow a closed quadruplet (ankan) to be counted as two separate pairs for this yaku
    let mut paired_tiles: Vec<String> = Vec::new();

    for (tile_suit, suit_counts) in tile_counts_by_suit.iter() {
        for (tile_rank, count) in suit_counts.iter() {
            let count = *count;
            if count != 2 {
                return false;
            } else {
                let mut tile_str = String::new();
                tile_str.push_str(tile_rank);
                tile_str.push_str(tile_suit);
                paired_tiles.push(tile_str);
            }
        }
    }

    return paired_tiles.len() == 7;
}

fn is_winning_hand(tiles: &Vec<String>) -> bool {
    // LESSON: if function is not meant to take ownership of the input argument, takeÂ in a reference

    // check hand length, must be minimum 14 tiles (could be more if there are quads)
    if tiles.len() < 14 {
        return false;
    }

    let tile_counts_by_suit: HashMap<&str, HashMap<&str, i32>> = count_tiles_by_suit_rank(tiles);
    println!("{:?}", tile_counts_by_suit);

    // TODO check for edge case hands: 7 pairs and 13 orphans
    if is_thirteen_orphans_yaku(&tile_counts_by_suit) || is_seven_pairs_yaku(&tile_counts_by_suit) {
        return true;
    }

    // there can be at most one pair
    let mut pair_tile = String::from("");

    // check honor tiles:
    // - any isolated honors? if so, not winning
    // - if there is a pair, that must be the only pair in the hand
    for (tile_suit, suit_counts) in &tile_counts_by_suit {
        if !HONOR_SUITS.contains(&tile_suit) {
            continue;
        }
        for (tile_rank, tile_count) in suit_counts {
            let mut new_tile_str = String::new();
            new_tile_str.push_str(tile_rank);
            new_tile_str.push_str(tile_suit);

            if tile_count == &1 {
                // isolated honor tile
                println!("isolated honor tile {new_tile_str}");
                return false;
            } else if tile_count == &2 {
                if !pair_tile.is_empty() {
                    // honor tile must be the pair, but can only have one pair in the winning hand
                    println!("pair of honor tile {new_tile_str} but already have a pair");
                    return false;
                } else {
                    pair_tile = new_tile_str;
                }
            }
        }
    }

    println!("pair tile so far = {}", pair_tile);

    // TODO check numbered suits:
    // - start from the lowest number in the suit
    // - there must be at least 2 tiles of that number, or a tile of each of the next two higher numbers
    // - once you make a grouping, then you take those tiles away and repear the process

    for tile_suit in NUMBER_SUITS {
        if let Some(tile_counts) = tile_counts_by_suit.get(tile_suit) {
            let mut keys: Vec<_> = tile_counts.keys().collect();
            keys.sort();
            for key in keys {
                if !tile_counts.contains_key(key) || tile_counts.get(key).unwrap() == &0 {
                    continue;
                }

                let mut sequence_possible = true;
                let mut set_possible = true;
                if key != &"8" && key != &"9" {
                    let char_u8 = (*key).as_bytes()[0] + 1;
                    let second_char = (char_u8 + 1) as char;
                    let third_char = (char_u8 + 2) as char;
                    let second_key = second_char.to_string();
                    let third_key = third_char.to_string();

                    // if there is no tile of the next rank or the rank after that, there can be no sequence starting from this tile
                    if (!tile_counts.contains_key(second_key.as_str()) || tile_counts.get(second_key.as_str()).unwrap() == &0) && (!tile_counts.contains_key(third_key.as_str()) || tile_counts.get(third_key.as_str()).unwrap() == &0) {
                        println!("sequence from {}m not possible", {key});
                        sequence_possible = false;
                    }

                    // TODO this is just a necessary requirement, we need to "consume" the sequence if it is the only possible way this tile can
                    // be not isolated e.g. 2345 cannot form two complete sequences but 233445 can
                } else {
                    println!("sequence from {}m not possible", {key});
                    sequence_possible = false;
                }
                if tile_counts.contains_key(key) && tile_counts.get(key).unwrap() < &3 {
                    set_possible = false;
                }

                println!("{}", key);
                if !sequence_possible && !set_possible {
                    // can this tile be the pair? must be no existing pair tile and there must be at least 2 copies of this tile
                    println!("isolated tile: {}{}", key, tile_suit);
                    return false;
                }
                // TODO certain hands
            }
        }
    }

    return true;
}

#[derive(Clone, Debug)]
struct HandMeld {
    meld_type: String, // one of: sequence, three-of-a-kind, four-of-a-kind
    // TODO make an enum
    is_open: bool, // indicates whether the meld is open (formed using a discard) or closed
    tiles: Vec<String>, // TODO replace with Tile class
}

#[derive(Clone, Debug)]
struct PartialWinningHand {
    // building a winning hand - if the pair_tile is none, it indicates there is no candidate pair_tile
    melds: Vec<HandMeld>,
    pair_tile: Option<String>, // TODO replace with Tile class
}

#[derive(Clone, Debug)]
struct WinningHand {
    melds: Vec<HandMeld>,
    pair_tile: String, // TODO replace with Tile class
}

fn _hand_grouping(tiles: &Vec<String>, partial_hand: &PartialWinningHand) -> Option<Vec<WinningHand>> {
    // returns Some if the remaining tiles can be grouped (three of a kind, four of a kind, or a sequence) and exactly one pair
    // can return multiple values if there are multiple valid groupings
    // TODO is this possible?

    // example: if the parameter partial_hand contains a pair already, and the only way to use a tile is in a pair, then this function would return none

    println!("number of remaining tiles: {}", tiles.len());
    println!("remaining tiles: {:?}", tiles);

    if tiles.is_empty() {
        if partial_hand.pair_tile.is_some() && partial_hand.melds.len() == 4 {
            let mut winning_hands = Vec::new();
            winning_hands.push(WinningHand {
                melds: partial_hand.melds.clone(),
                pair_tile: partial_hand.pair_tile.clone().unwrap().clone(),
            });
            return Some(winning_hands);
        } else {
            return None;
        }
    }
    if tiles.len() == 1 {
        return None;
    }
    if tiles.len() == 2 {
        // if there are only two tiles left, the only way this can be a winning hand is if
        // the remaining tiles form the pair
        if tiles.get(0).unwrap() != tiles.get(1).unwrap() {
            return None;
        }
        if partial_hand.pair_tile.is_some() {
            return None;
        }
        let mut winning_hands = Vec::new();
        winning_hands.push(WinningHand {
            melds: partial_hand.melds.clone(),
            pair_tile: tiles.get(0).unwrap().clone(),
        });
        return Some(winning_hands);
    }
    // TODO handle case with three tiles left here or by suit?
    // if tiles.len() == 3 {
    // }

    // TODO handle case with four tiles left here or by suit?
    // if tiles.len() == 4 {
    //     // if there are only four tiles left, the only way this can be a winning hand is if
    //     // the remaining tiles form a quad
    //     let first_tile = tiles.get(0).unwrap();
    //     let remaining_tiles: Vec<_> = tiles.iter().filter(|&tile| tile != first_tile).cloned().collect();
    //     if !remaining_tiles.is_empty() {
    //         return None;
    //     }
    //     if !partial_hand.pair_tile.is_some() {
    //         // if there's not already a pair, this isn't a winning hand
    //         return None;
    //     }
    //     let mut new_melds = partial_hand.melds.clone();
    //     new_melds.push(HandMeld {
    //         meld_type: String::from("quad"),
    //         is_open: false, // TODO handle this properly
    //         tiles: tiles.clone(),
    //     });
    //     let new_partial_hand = PartialWinningHand {
    //         melds: new_melds,
    //         pair_tile: partial_hand.pair_tile.clone(),
    //     };
    //     return _hand_grouping(&remaining_tiles, &new_partial_hand);
    // }

    // this works with partial hand states e.g. excluding tiles from open melds, and when working recursively
    let remaining_tiles = tiles.clone();

    let tile_counts_by_suit: HashMap<&str, HashMap<&str, i32>> = count_tiles_by_suit_rank(&remaining_tiles);

    // check honor tiles:
    // - any isolated honors? if so, not winning
    // - if there is a pair, that must be the only pair in the hand
    for tile_suit in HONOR_SUITS {
        if let Some(honor_counts) = tile_counts_by_suit.get(tile_suit) {
            for (tile_rank, tile_count) in honor_counts {
                let mut new_tile_str = String::new();
                new_tile_str.push_str(tile_rank);
                new_tile_str.push_str(tile_suit);
                let new_tile_str = new_tile_str;

                if tile_count == &0 {
                    continue;
                }
                if tile_count == &1 {
                    // isolated honor tile
                    println!("isolated honor tile {new_tile_str}");
                    return None;
                } else if tile_count == &2 {
                    if partial_hand.pair_tile.is_some() {
                        // honor tile must be the pair, but can only have one pair in the winning hand
                        println!("pair of honor tile {new_tile_str} but already have a pair");
                        return None;
                    } else {
                        // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                        // no way for a single honor tile type to be used in more than one meld/group
                        let remaining_tiles: Vec<_> = remaining_tiles.iter().filter(|&tile| tile != &new_tile_str).cloned().collect();
                        println!("found pair of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);
                        let new_partial_hand = PartialWinningHand {
                            melds: partial_hand.melds.clone(),
                            pair_tile: Some(new_tile_str),
                        };

                        // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                        return _hand_grouping(&remaining_tiles, &new_partial_hand);
                    }
                } else {
                    // a triplet or a quad

                    // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                    // no way for a single honor tile type to be used in more than one meld/group
                    let remaining_tiles: Vec<_> = remaining_tiles.iter().filter(|&tile| tile != &new_tile_str).cloned().collect();
                    println!("found set of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);
                    let new_partial_hand = partial_hand.clone();

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return _hand_grouping(&remaining_tiles, &new_partial_hand);
                }
            }
        }
    }

    // check number suits
    for tile_suit in NUMBER_SUITS {
        if let Some(tile_counts) = tile_counts_by_suit.get(tile_suit) {
            for (tile_rank, tile_count) in tile_counts {
                let mut new_tile_str = String::new();
                new_tile_str.push_str(tile_rank);
                new_tile_str.push_str(tile_suit);
                let new_tile_str = new_tile_str;

                if tile_count == &0 {
                    continue;
                }
                if tile_count == &1 {
                    // isolated number tile
                    // TODO at first, only checking for triplets/quads, this is not actually a disqualifier for a winning hand
                    println!("isolated tile {new_tile_str}");
                    return None;
                } else if tile_count == &2 {
                    if partial_hand.pair_tile.is_some() {
                        println!("pair of tile {new_tile_str} but already have a pair");
                        // TODO at first, only checking for triplets/quads, this is not actually a disqualifier for a winning hand
                        // e.g. could have a winning hand that uses two of a number tile in two sequences
                        return None;
                    } else {
                        // TODO at first, only checking for triplets/quads, using both copies as a pair isn't the only option
                        // e.g. could have a winning hand that uses two of a number tile in two sequences
                        let remaining_tiles: Vec<_> = remaining_tiles.iter().filter(|&tile| tile != &new_tile_str).cloned().collect();
                        println!("found pair of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);
                        let new_partial_hand = PartialWinningHand {
                            melds: partial_hand.melds.clone(),
                            pair_tile: Some(new_tile_str),
                        };

                        // TODO at first, only checking for triplets/quads, this is not the only option
                        return _hand_grouping(&remaining_tiles, &new_partial_hand);
                    }
                } else {
                    // a triplet or a quad
                    // TODO at first, only checking for triplets/quads, using all copies as a set isn't the only option
                    //  (e.g. could use four copies as triplet + one in a sequence, or pair + two sequences, etc.)
                    //  (e.g. could use three copies as a pair + one in a sequence, or three different sequences, etc)
                    let remaining_tiles: Vec<_> = remaining_tiles.iter().filter(|&tile| tile != &new_tile_str).cloned().collect();
                    println!("found set of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);
                    let new_partial_hand = partial_hand.clone();

                    // TODO at first, only checking for triplets/quads, this is not the only option
                    return _hand_grouping(&remaining_tiles, &new_partial_hand);
                }
            }
        }
    }

    return None;
}


fn main() {
    // let tile = Tile { suit: TileSuit::Man, rank: NumberTileType::Five};
    // println!("It's a tile: {}", tile.repr());

    let mut hand: Vec<String> = Vec::new();
    hand.push(String::from("1s"));
    hand.push(String::from("2s"));
    hand.push(String::from("3s"));
    hand.push(String::from("4s"));
    hand.push(String::from("5s"));
    hand.push(String::from("6s"));
    hand.push(String::from("7s"));
    hand.push(String::from("8s"));
    hand.push(String::from("9s"));
    hand.push(String::from("Wd"));
    hand.push(String::from("Wd"));
    hand.push(String::from("Wd"));
    hand.push(String::from("Nw"));
    hand.push(String::from("Nw"));
    println!("hand:");
    for tile in &hand {
        println!("{tile}");
    }
    println!("is winning hand? {}", is_winning_hand(&hand));
}

#[cfg(test)]
mod tests {
    // importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_count_tiles_by_suit_rank() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("8m"),
            String::from("8m"),
            String::from("Gd"),
            String::from("Gd"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
        ]);

        let counts = count_tiles_by_suit_rank(&tiles);
        assert_eq!(counts.get("m").unwrap().get("1"), Some(&3));
        assert_eq!(counts.get("m").unwrap().get("2"), Some(&1));
        assert_eq!(counts.get("m").unwrap().get("3"), Some(&1));
        assert_eq!(counts.get("m").unwrap().get("4"), Some(&1));
        assert_eq!(counts.get("m").unwrap().get("8"), Some(&2));
        assert_eq!(counts.get("d").unwrap().get("G"), Some(&2));
        assert_eq!(counts.get("w").unwrap().get("W"), Some(&3));
    }

    #[test]
    fn test_is_thirteen_orphans_yaku() {
        // from: https://riichi.wiki/Kokushi_musou
        let tiles = Vec::from([
            String::from("1m"),
            String::from("9m"),
            String::from("1p"),
            String::from("9p"),
            String::from("1s"),
            String::from("9s"),
            String::from("Ew"),
            String::from("Sw"),
            String::from("Ww"),
            String::from("Nw"),
            String::from("Gd"),
            String::from("Rd"),
            String::from("Wd"),
        ]);

        // Iterate over a slice to avoid moving the value of `tiles` variable into the for loop
        for winning_tile in &tiles {
            let mut new_tiles = tiles.clone();
            new_tiles.push(winning_tile.to_string());
            let new_tiles_count_by_suit = count_tiles_by_suit_rank(&new_tiles);
            assert_eq!(is_thirteen_orphans_yaku(&new_tiles_count_by_suit), true);
        }
        let tiles_count_by_suit = count_tiles_by_suit_rank(&tiles);
        assert_eq!(is_thirteen_orphans_yaku(&tiles_count_by_suit), false);
    }

    #[test]
    fn test_is_seven_pairs_yaku() {
        // from: https://riichi.wiki/Chiitoitsu
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("3m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5p"),
            String::from("5p"),
            String::from("2s"),
            String::from("2s"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Wd"),
            String::from("Wd"),
        ]);

        let tiles_count_by_suit = count_tiles_by_suit_rank(&tiles);
        assert_eq!(is_seven_pairs_yaku(&tiles_count_by_suit), false);

        let mut new_tiles = tiles.clone();
        new_tiles.push(String::from("4m"));
        let new_tiles_count_by_suit = count_tiles_by_suit_rank(&new_tiles);
        assert_eq!(is_seven_pairs_yaku(&new_tiles_count_by_suit), true);
    }

    #[test]
    fn test_is_winning_hand_half_flush() {
        // from: https://riichi.wiki/Honiisou
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("8m"),
            String::from("8m"),
            String::from("Gd"),
            String::from("Gd"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
        ]);

        for winning_tile in [String::from("8m"), String::from("Gd")] {
            let mut new_tiles = tiles.clone();
            new_tiles.push(winning_tile);
            assert_eq!(is_winning_hand(&new_tiles), true);
        }
        assert_eq!(is_winning_hand(&tiles), false);
    }

    #[test]
    fn test_is_winning_hand_isolated_honor() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("9m"),
            String::from("9m"),
            String::from("Ww"), // isolated honor tile
        ]);
        assert_eq!(is_winning_hand(&tiles), false);
    }

    #[test]
    fn test_is_winning_hand_isolated_number() {
        let tiles = Vec::from([
            String::from("1m"), // isolated number tile
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("2s"),
            String::from("2s"),
            String::from("2s"),
            String::from("Rd"),
            String::from("Rd"),
            String::from("Rd"),
        ]);
        assert_eq!(is_winning_hand(&tiles), false);
    }

    #[test]
    fn test_is_winning_hand_nine_gates() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("9m"),
            String::from("9m"),
        ]);
        for rank in 1..=9 {
            let mut new_tiles = tiles.clone();
            let mut added_tile = String::from(rank.to_string());
            added_tile.push('m');
            new_tiles.push(added_tile);
            assert_eq!(is_winning_hand(&new_tiles), true);
        }
    }


    #[test]
    fn test_hand_grouping_big_winds() {
        // Four groups (triplets or quads), one for each wind tile
        // From https://riichi.wiki/List_of_yaku (Daisuushii)
        let mut tiles = Vec::from([
            String::from("Ew"),
            String::from("Ew"),
            String::from("Ew"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Nw"),
            String::from("Nw"),
            String::from("Nw"),
            String::from("5p"),
        ]);

        let partial_hand = PartialWinningHand {
            melds: Vec::new(),
            pair_tile: None,
        };

        assert!(!_hand_grouping(&tiles, &partial_hand).is_some());

        // add winning tile: 5p
        tiles.push(String::from("5p"));
        assert!(_hand_grouping(&tiles, &partial_hand).is_some());
    }


    #[test]
    fn test_hand_grouping_little_winds() {
        // Three groups (triplets or quads) of different winds, and a pair of the fourth
        // From https://riichi.wiki/List_of_yaku (Shousuushii)
        let mut tiles = Vec::from([
            String::from("8m"),
            String::from("8m"),
            String::from("8m"),
            String::from("Ew"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Nw"),
            String::from("Nw"),
            String::from("Nw"),
        ]);

        let partial_hand = PartialWinningHand {
            melds: Vec::new(),
            pair_tile: None,
        };

        assert!(!_hand_grouping(&tiles, &partial_hand).is_some());

        // add winning tile: Ew
        tiles.push(String::from("Ew"));
        assert!(_hand_grouping(&tiles, &partial_hand).is_some());
    }
}
