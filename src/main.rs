// pub mod tiles;
// use crate::tiles::Tile;

use std::collections::HashSet;
use std::collections::HashMap;
use std::fmt;

const NUMBER_TILES: [&str; 9] = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
const WIND_TILES: [&str; 4] = ["E", "S", "W", "N"];
const DRAGON_TILES: [&str; 3] = ["G", "R", "W"];
// const TILE_SUITS: [&str; 5] = ["m", "p", "s", "w", "d"];
const HONOR_SUITS: [&str; 2] = ["w", "d"];
const NUMBER_SUITS: [&str; 3] = ["m", "p", "s"];

// fn check_valid_tile_string(tile_str: &String) {
//     assert!(tile_str.len() == 2);
//     let tile_rank = tile_str.get(0..1).expect("Expected tile rank");
//     let tile_suit = tile_str.get(1..2).expect("Expected tile suit");
//     assert!(
//         NUMBER_TILES.contains(&tile_rank)
//             || WIND_TILES.contains(&tile_rank)
//             || DRAGON_TILES.contains(&tile_rank)
//     );
//     assert!(TILE_SUITS.contains(&tile_suit));
// }

fn count_tiles_by_suit_rank(tiles: &Vec<String>) -> HashMap<&str, HashMap<&str, i32>> {
    // build frequency count per tile suit: mapping of tile suit -> (mapping of rank -> count)
    let mut tile_counts_by_suit: HashMap<&str, HashMap<&str, i32>> = HashMap::new();
    /* section generated by ChatGPT Mar 23 version:
     * prompt:
     * Write a program in Rust that takes in a Vector<String> where each element is a 2-character ASCII string,
     * and returns a HashMap<&str, HashMap<&str, i32>> that contains the counts of each (first character, second
     * character) pair in the input Vector, grouped by the outer key.
     * Example input: [String::from("a1"), String::from("a1"), String::from("a2"), String::from("b2")]
     * Example output: {"a": {"1": 2, "2": 1}, "b": {"2": 1}}
     */
    for s in tiles.iter() {
        let (tile_rank, tile_suit) = s.split_at(1);
        let inner_map = tile_counts_by_suit
            .entry(tile_suit)
            .or_insert_with(HashMap::new);
        *inner_map.entry(tile_rank).or_insert(0) += 1;
    }
    // end section generated by ChatGPT

    // prior attempts to build the tile_counts_by_suit nested map
    // for tile_str in tiles {
    //     let tile_rank = tile_str.get(0..1).expect("Expected tile rank");
    //     let tile_suit = tile_str.get(1..2).expect("Expected tile suit");

    //     // if-else on contains_key (can also use if-left to initialize suit_counts in if block)
    //     if tile_counts_by_suit.contains_key(&tile_suit) {
    //         let suit_counts = tile_counts_by_suit.get_mut(&tile_suit).unwrap();
    //         let count = suit_counts.entry(tile_rank).or_insert(0);
    //         *count += 1;
    //     } else {
    //         let mut empty_counts = HashMap::new();
    //         // we have to update/mutate `empty_counts` before we call `tile_counts_by_suit.insert(...)`,
    //         //  as that insert will transfer ownership of `empty_counts`
    //         empty_counts.insert(tile_rank, 1);
    //         tile_counts_by_suit.insert(tile_suit, empty_counts);
    //     }
    // }

    tile_counts_by_suit
}

fn is_thirteen_orphans_yaku(tile_counts_by_suit: &HashMap<&str, HashMap<&str, i32>>) -> bool {
    // Returns true iff the hand is a winning hand by the thirteen orphans yaku (aka "kokushi musou", or just "kokushi")
    let mut paired_tile = String::from("");

    // check winds:
    match tile_counts_by_suit.get("w") {
        Some(wind_counts) => {
            for wind_tile in WIND_TILES {
                let count = wind_counts.get(wind_tile).unwrap_or(&0);
                let count = *count;
                if count > 2 {
                    return false;
                } else if count == 2 {
                    // exactly one of the "orphans" (terminal number tiles and honor tiles)
                    // must be paired in thirteen orphans yaku
                    if paired_tile.is_empty() {
                        paired_tile.push_str(wind_tile);
                        paired_tile.push_str("w");
                        continue;
                    } else {
                        return false;
                    }
                }
            }
        }
        // no winds entirely disqualifies the hand from thirteen orphans yaku
        None => return false,
    };

    // check dragons:
    match tile_counts_by_suit.get("d") {
        Some(dragon_counts) => {
            for dragon_tile in DRAGON_TILES {
                let count = dragon_counts.get(dragon_tile).unwrap_or(&0);
                let count = *count;
                if count > 2 {
                    return false;
                } else if count == 2 {
                    // exactly one of the "orphans" (terminal number tiles and honor tiles)
                    // must be paired in thirteen orphans yaku
                    if paired_tile.is_empty() {
                        paired_tile.push_str(dragon_tile);
                        paired_tile.push_str("w");
                        continue;
                    } else {
                        return false;
                    }
                }
            }
        }
        // no dragons entirely disqualifies the hand from thirteen orphans yaku
        None => return false,
    };

    // check number suits:
    for tile_suit in NUMBER_SUITS {
        match tile_counts_by_suit.get(tile_suit) {
            Some(tile_counts) => {
                for tile_rank in NUMBER_TILES {
                    let count = tile_counts.get(tile_rank).unwrap_or(&0);
                    let count = *count;
                    if tile_rank == "1" || tile_rank == "9" {
                        if count > 2 {
                            return false;
                        } else if count == 2 {
                            // exactly one of the "orphans" (terminal number tiles and honor tiles)
                            // must be paired in thirteen orphans yaku
                            if paired_tile.is_empty() {
                                paired_tile.push_str(tile_rank);
                                paired_tile.push_str(tile_suit);
                                continue;
                            } else {
                                return false;
                            }
                        }
                    } else if count > 0 {
                        // any non-terminal number tiles (i.e. not 1 or 9) tiles immediately disqualifies the hand from thirteen orphans yaku
                        return false;
                    }
                }
            }
            // missing a number suit entirely disqualifies the hand from thirteen orphans yaku
            None => return false,
        };
    }

    // at the end, there still must be a single paired tile
    return !paired_tile.is_empty();
}

fn is_seven_pairs_yaku(tile_counts_by_suit: &HashMap<&str, HashMap<&str, i32>>) -> bool {
    // Returns true iff the hand is a winning hand by the seven pairs yaku (aka "chiitoitsu", "chiitoi", "niconico")
    // Note: does not allow a closed quadruplet (ankan) to be counted as two separate pairs for this yaku
    let mut paired_tiles: Vec<String> = Vec::new();

    for (tile_suit, suit_counts) in tile_counts_by_suit.iter() {
        for (tile_rank, count) in suit_counts.iter() {
            let count = *count;
            if count != 2 {
                return false;
            } else {
                let mut tile_str = String::new();
                tile_str.push_str(tile_rank);
                tile_str.push_str(tile_suit);
                paired_tiles.push(tile_str);
            }
        }
    }

    return paired_tiles.len() == 7;
}

fn is_winning_hand(tiles: &Vec<String>) -> bool {
    // LESSON: if function is not meant to take ownership of the input argument, takeÂ in a reference

    // check hand length, must be minimum 14 tiles (could be more if there are quads)
    if tiles.len() < 14 {
        return false;
    }

    let tile_counts_by_suit: HashMap<&str, HashMap<&str, i32>> = count_tiles_by_suit_rank(tiles);
    println!("{:?}", tile_counts_by_suit);

    // check for edge case hands: 7 pairs and 13 orphans
    if is_thirteen_orphans_yaku(&tile_counts_by_suit) || is_seven_pairs_yaku(&tile_counts_by_suit) {
        return true;
    }

    // otherwise, see if you can make a hand grouping
    let new_tiles = tiles.clone();
    let partial_hand = PartialWinningHand {
        melds: Vec::new(),
        pair_tile: None,
    };
    let grouping_result = _hand_grouping(&new_tiles, &partial_hand);

    return grouping_result.is_some();
}

#[derive(Clone)]
struct HandMeld {
    meld_type: String, // one of: sequence, three-of-a-kind, four-of-a-kind
    // TODO make an enum
    is_open: bool, // indicates whether the meld is open (formed using a discard) or closed
    tiles: HashSet<String>, // TODO replace with Tile class
}

impl fmt::Debug for HandMeld {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("HandMeld")
         .field("meld_type", &self.meld_type)
         .field("is_open", &self.is_open)
         .field("tiles", &self.tiles)
         .finish()
    }
}

impl PartialEq for HandMeld {
    fn eq(&self, other: &Self) -> bool {
        self.meld_type == other.meld_type && self.is_open == other.is_open && self.tiles == other.tiles
    }
}

#[derive(Clone, Debug)]
struct PartialWinningHand {
    // building a winning hand - if the pair_tile is none, it indicates there is no candidate pair_tile
    melds: Vec<HandMeld>,
    pair_tile: Option<String>, // TODO replace with Tile class
}

#[derive(Clone, Debug)]
struct WinningHand {
    melds: Vec<HandMeld>,
    pair_tile: String, // TODO replace with Tile class
}

fn _remove_one_copy(tiles: &Vec<String>, tile_to_remove: &String) -> Vec<String> {
    // TODO how come the tiles.splitn(1, |tile| *tile == *tile_to_remove) approach doesn't work here?

    // println!("tile_to_remove: {:?}", *tile_to_remove);
    let mut found_idx: Option<usize> = None;
    for tile_idx in 0..tiles.len() {
        let tile = tiles.get(tile_idx).unwrap();
        // println!("tile: {:?}", tile);
        if *tile == *tile_to_remove {
            found_idx = Some(tile_idx);
            break;
        }
    }
    let mut new_tiles: Vec<String> = tiles.clone();
    if found_idx.is_some() {
        new_tiles.remove(found_idx.unwrap());
    }
    return new_tiles;
}

fn _hand_grouping(tiles: &Vec<String>, partial_hand: &PartialWinningHand) -> Option<Vec<WinningHand>> {
    // returns Some if the remaining tiles can be grouped (three of a kind, four of a kind, or a sequence) and exactly one pair
    // can return multiple values if there are multiple valid groupings
    // TODO is this possible?

    // example: if the parameter partial_hand contains a pair already, and the only way to use a tile is in a pair, then this function would return none

    println!("number of remaining tiles: {}", tiles.len());
    println!("remaining tiles: {:?}", tiles);

    if tiles.is_empty() {
        println!("partial hand so far:");
        println!("pair tile: {:?}", partial_hand.pair_tile);
        println!("melds: {:?}", partial_hand.melds);
        if partial_hand.pair_tile.is_some() && partial_hand.melds.len() == 4 {
            let mut winning_hands = Vec::new();
            winning_hands.push(WinningHand {
                melds: partial_hand.melds.clone(),
                pair_tile: partial_hand.pair_tile.clone().unwrap().clone(),
            });
            return Some(winning_hands);
        } else {
            return None;
        }
    }
    if tiles.len() == 1 {
        return None;
    }
    if tiles.len() == 2 {
        // if there are only two tiles left, the only way this can be a winning hand is if
        // the remaining tiles form the pair
        if tiles.get(0).unwrap() != tiles.get(1).unwrap() {
            return None;
        }
        if partial_hand.pair_tile.is_some() {
            return None;
        }
        let mut winning_hands = Vec::new();
        winning_hands.push(WinningHand {
            melds: partial_hand.melds.clone(),
            pair_tile: tiles.get(0).unwrap().clone(),
        });
        return Some(winning_hands);
    }

    // this works with partial hand states e.g. excluding tiles from open melds, and when working recursively
    let remaining_tiles = tiles.clone();

    let tile_counts_by_suit: HashMap<&str, HashMap<&str, i32>> = count_tiles_by_suit_rank(&remaining_tiles);

    // check honor tiles:
    // - any isolated honors? if so, not winning
    // - if there is a pair, that must be the only pair in the hand
    for tile_suit in HONOR_SUITS {
        if let Some(honor_counts) = tile_counts_by_suit.get(tile_suit) {
            for (tile_rank, tile_count) in honor_counts {
                let mut new_tile_str = String::new();
                new_tile_str.push_str(tile_rank);
                new_tile_str.push_str(tile_suit);
                let new_tile_str = new_tile_str;

                if tile_count == &0 {
                    continue;
                }
                if tile_count == &1 {
                    // isolated honor tile
                    println!("isolated honor tile {new_tile_str}");
                    return None;
                } else if tile_count == &2 {
                    if partial_hand.pair_tile.is_some() {
                        // honor tile must be the pair, but can only have one pair in the winning hand
                        println!("pair of honor tile {new_tile_str} but already have a pair");
                        return None;
                    } else {
                        // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                        // no way for a single honor tile type to be used in more than one meld/group
                        let remaining_tiles: Vec<_> = remaining_tiles.iter().filter(|&tile| tile != &new_tile_str).cloned().collect();
                        println!("found pair of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);
                        let new_partial_hand = PartialWinningHand {
                            melds: partial_hand.melds.clone(),
                            pair_tile: Some(new_tile_str),
                        };

                        // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                        return _hand_grouping(&remaining_tiles, &new_partial_hand);
                    }
                } else if tile_count == &3 || tile_count == &4 {
                    // a triplet or a quad

                    // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                    // no way for a single honor tile type to be used in more than one meld/group
                    let removed_tiles: Vec<_> = remaining_tiles.iter().filter(|&tile| tile == &new_tile_str).cloned().collect();
                    let remaining_tiles: Vec<_> = remaining_tiles.iter().filter(|&tile| tile != &new_tile_str).cloned().collect();
                    println!("found set of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);
                    let new_meld = HandMeld {
                        meld_type: if tile_count == &3 { "triplet".to_string() } else { "quad".to_string() },
                        is_open: false, // TODO handle this properly
                        tiles: HashSet::from_iter(removed_tiles),
                    };
                    let mut new_melds = partial_hand.melds.clone();
                    new_melds.push(new_meld);
                    let new_partial_hand = PartialWinningHand {
                        melds: new_melds,
                        pair_tile: partial_hand.pair_tile.clone(),
                    };

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return _hand_grouping(&remaining_tiles, &new_partial_hand);
                } else {
                    println!("impossible, cannot be more than 4 tiles!");
                    return None;
                }
            }
        }
    }

    // check number suits
    for tile_suit in NUMBER_SUITS {
        if let Some(tile_counts) = tile_counts_by_suit.get(tile_suit) {
            for rank in 1..=9 {
                let tile_rank_string = rank.to_string();
                let tile_rank = tile_rank_string.as_str();

                // TODO refactor?
                let mut new_tile_str = String::new();
                new_tile_str.push_str(tile_rank);
                new_tile_str.push_str(tile_suit);
                let new_tile_str = new_tile_str;

                let tile_count = tile_counts.get(tile_rank).unwrap_or(&0);
                if tile_count == &0 {
                    continue;
                }

                let mut winning_hands: Vec<WinningHand> = Vec::new();
                if tile_count >= &1 {
                    // single number tile can be used for sequence

                    // check for presence of higher rank tiles
                    // TODO refactor?
                    let second_rank = rank + 1;
                    let third_rank = rank + 2;
                    let second_rank_string = second_rank.to_string();
                    let third_rank_string = third_rank.to_string();
                    let second_rank_str = second_rank_string.as_str();
                    let third_rank_str = third_rank_string.as_str();

                    let mut second_tile_str = String::new();
                    second_tile_str.push_str(second_rank_str);
                    second_tile_str.push_str(tile_suit);
                    let second_tile_str = second_tile_str;

                    let mut third_tile_str = String::new();
                    third_tile_str.push_str(third_rank_str);
                    third_tile_str.push_str(tile_suit);
                    let third_tile_str = third_tile_str;

                    if tile_counts.get(second_rank_str).unwrap_or(&0) > &0 && tile_counts.get(third_rank_str).unwrap_or(&0) > &0 {
                        println!("checking for sequence starting at {new_tile_str}");
                        // build remaining tiles by removing one copy of each of the three tiles in the sequence
                        let mut removed_tiles: Vec<String> = Vec::new();
                        removed_tiles.push(new_tile_str.clone());
                        removed_tiles.push(second_tile_str.clone());
                        removed_tiles.push(third_tile_str.clone());
                        let remaining_tiles: Vec<String> = tiles.clone();
                        let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                        let remaining_tiles = _remove_one_copy(&remaining_tiles, &second_tile_str);
                        let remaining_tiles = _remove_one_copy(&remaining_tiles, &third_tile_str);

                        // new meld
                        let new_meld = HandMeld {
                            meld_type: "sequence".to_string(),
                            is_open: false, // TODO handle this properly
                            tiles: HashSet::from_iter(removed_tiles),
                        };

                        // recursive call
                        let mut new_melds = partial_hand.melds.clone();
                        new_melds.push(new_meld);
                        let new_partial_hand = PartialWinningHand {
                            melds: new_melds,
                            pair_tile: partial_hand.pair_tile.clone(),
                        };
                        if let Some(new_winning_hands) = _hand_grouping(&remaining_tiles, &new_partial_hand) {
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }
                if tile_count >= &2 {
                    // two copies of number tile can be used for pair

                    // make sure there is no existing tile marked as pair
                    if !partial_hand.pair_tile.is_some() {
                        // build remaining tiles by removing two copies of the tile
                        let remaining_tiles: Vec<String> = tiles.clone();
                        let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                        let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                        println!("found pair of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);

                        // recursive call
                        let new_partial_hand = PartialWinningHand {
                            melds: partial_hand.melds.clone(),
                            // TODO why does compiler recommend cloning here if performance is acceptable?
                            pair_tile: Some(new_tile_str.clone()),
                        };

                        if let Some(new_winning_hands) = _hand_grouping(&remaining_tiles, &new_partial_hand) {
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }
                if tile_count >= &3 {
                    // three copies of number tile can be used for triplet
                    println!("checking for triplet of {new_tile_str}");

                    // build remaining tiles by removing three copies of the tile
                    let mut removed_tiles: Vec<String> = Vec::new();
                    removed_tiles.push(new_tile_str.clone());
                    removed_tiles.push(new_tile_str.clone());
                    removed_tiles.push(new_tile_str.clone());

                    let remaining_tiles: Vec<String> = tiles.clone();
                    let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                    let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                    let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);

                    // new meld
                    let new_meld = HandMeld {
                        meld_type: "triplet".to_string(),
                        is_open: false, // TODO handle this properly
                        tiles: HashSet::from_iter(removed_tiles),
                    };

                    // recursive call
                    let mut new_melds = partial_hand.melds.clone();
                    new_melds.push(new_meld);
                    let new_partial_hand = PartialWinningHand {
                        melds: new_melds,
                        pair_tile: partial_hand.pair_tile.clone(),
                    };
                    if let Some(new_winning_hands) = _hand_grouping(&remaining_tiles, &new_partial_hand) {
                        winning_hands.extend(new_winning_hands);
                    }
                }
                if tile_count >= &4 {
                    // three copies of number tile can be used for quad
                    println!("checking for quad of {new_tile_str}");

                    // build remaining tiles by removing four copies of the tile
                    let mut removed_tiles: Vec<String> = Vec::new();
                    removed_tiles.push(new_tile_str.clone());
                    removed_tiles.push(new_tile_str.clone());
                    removed_tiles.push(new_tile_str.clone());
                    removed_tiles.push(new_tile_str.clone());

                    let remaining_tiles: Vec<String> = tiles.clone();
                    let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                    let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                    let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);
                    let remaining_tiles = _remove_one_copy(&remaining_tiles, &new_tile_str);

                    // new meld
                    let new_meld = HandMeld {
                        meld_type: "quad".to_string(),
                        is_open: false, // TODO handle this properly
                        tiles: HashSet::from_iter(removed_tiles),
                    };

                    // recursive call
                    let mut new_melds = partial_hand.melds.clone();
                    new_melds.push(new_meld);
                    let new_partial_hand = PartialWinningHand {
                        melds: new_melds,
                        pair_tile: partial_hand.pair_tile.clone(),
                    };
                    if let Some(new_winning_hands) = _hand_grouping(&remaining_tiles, &new_partial_hand) {
                        winning_hands.extend(new_winning_hands);
                    }
                }

                // we have to use this tile in the winning hand somehow - if there's no winning hands at this point,
                // then there are no winning hands at all
                return if winning_hands.is_empty() { None } else { Some(winning_hands) };
            }
        }
    }

    return None;
}


fn main() {
    // let tile = Tile { suit: TileSuit::Man, rank: NumberTileType::Five};
    // println!("It's a tile: {}", tile.repr());

    let mut hand: Vec<String> = Vec::new();
    hand.push(String::from("1s"));
    hand.push(String::from("2s"));
    hand.push(String::from("3s"));
    hand.push(String::from("4s"));
    hand.push(String::from("5s"));
    hand.push(String::from("6s"));
    hand.push(String::from("7s"));
    hand.push(String::from("8s"));
    hand.push(String::from("9s"));
    hand.push(String::from("Wd"));
    hand.push(String::from("Wd"));
    hand.push(String::from("Wd"));
    hand.push(String::from("Nw"));
    hand.push(String::from("Nw"));
    println!("hand:");
    for tile in &hand {
        println!("{tile}");
    }
    println!("is winning hand? {}", is_winning_hand(&hand));
}

#[cfg(test)]
mod tests {
    // importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_count_tiles_by_suit_rank() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("8m"),
            String::from("8m"),
            String::from("Gd"),
            String::from("Gd"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
        ]);

        let counts = count_tiles_by_suit_rank(&tiles);
        assert_eq!(counts.get("m").unwrap().get("1"), Some(&3));
        assert_eq!(counts.get("m").unwrap().get("2"), Some(&1));
        assert_eq!(counts.get("m").unwrap().get("3"), Some(&1));
        assert_eq!(counts.get("m").unwrap().get("4"), Some(&1));
        assert_eq!(counts.get("m").unwrap().get("8"), Some(&2));
        assert_eq!(counts.get("d").unwrap().get("G"), Some(&2));
        assert_eq!(counts.get("w").unwrap().get("W"), Some(&3));
    }

    #[test]
    fn test_is_thirteen_orphans_yaku() {
        // from: https://riichi.wiki/Kokushi_musou
        let tiles = Vec::from([
            String::from("1m"),
            String::from("9m"),
            String::from("1p"),
            String::from("9p"),
            String::from("1s"),
            String::from("9s"),
            String::from("Ew"),
            String::from("Sw"),
            String::from("Ww"),
            String::from("Nw"),
            String::from("Gd"),
            String::from("Rd"),
            String::from("Wd"),
        ]);

        // Iterate over a slice to avoid moving the value of `tiles` variable into the for loop
        for winning_tile in &tiles {
            let mut new_tiles = tiles.clone();
            new_tiles.push(winning_tile.to_string());
            let new_tiles_count_by_suit = count_tiles_by_suit_rank(&new_tiles);
            assert_eq!(is_thirteen_orphans_yaku(&new_tiles_count_by_suit), true);
        }
        let tiles_count_by_suit = count_tiles_by_suit_rank(&tiles);
        assert_eq!(is_thirteen_orphans_yaku(&tiles_count_by_suit), false);
    }

    #[test]
    fn test_is_seven_pairs_yaku() {
        // from: https://riichi.wiki/Chiitoitsu
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("3m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5p"),
            String::from("5p"),
            String::from("2s"),
            String::from("2s"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Wd"),
            String::from("Wd"),
        ]);

        let tiles_count_by_suit = count_tiles_by_suit_rank(&tiles);
        assert_eq!(is_seven_pairs_yaku(&tiles_count_by_suit), false);

        let mut new_tiles = tiles.clone();
        new_tiles.push(String::from("4m"));
        let new_tiles_count_by_suit = count_tiles_by_suit_rank(&new_tiles);
        assert_eq!(is_seven_pairs_yaku(&new_tiles_count_by_suit), true);
    }

    #[test]
    fn test_is_winning_hand_half_flush() {
        // from: https://riichi.wiki/Honiisou
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("8m"),
            String::from("8m"),
            String::from("Gd"),
            String::from("Gd"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
        ]);

        for winning_tile in [String::from("8m"), String::from("Gd")] {
            let mut new_tiles = tiles.clone();
            new_tiles.push(winning_tile);
            assert_eq!(is_winning_hand(&new_tiles), true);
        }
        assert_eq!(is_winning_hand(&tiles), false);
    }

    #[test]
    fn test_is_winning_hand_isolated_honor() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("9m"),
            String::from("9m"),
            String::from("Ww"), // isolated honor tile
        ]);
        assert_eq!(is_winning_hand(&tiles), false);
    }

    #[test]
    fn test_is_winning_hand_isolated_number() {
        let tiles = Vec::from([
            String::from("1m"), // isolated number tile
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("2s"),
            String::from("2s"),
            String::from("2s"),
            String::from("Rd"),
            String::from("Rd"),
            String::from("Rd"),
        ]);
        assert_eq!(is_winning_hand(&tiles), false);
    }

    #[test]
    fn test_is_winning_hand_nine_gates() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("9m"),
            String::from("9m"),
        ]);
        for rank in 1..=9 {
            let mut new_tiles = tiles.clone();
            let mut added_tile = String::from(rank.to_string());
            added_tile.push('m');
            new_tiles.push(added_tile);
            assert_eq!(is_winning_hand(&new_tiles), true);
        }
    }

    #[test]
    fn test_hand_grouping_big_winds() {
        // Four groups (triplets or quads), one for each wind tile
        // From https://riichi.wiki/List_of_yaku (Daisuushii)
        let mut tiles = Vec::from([
            String::from("Ew"),
            String::from("Ew"),
            String::from("Ew"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Nw"),
            String::from("Nw"),
            String::from("Nw"),
            String::from("5p"),
        ]);

        let partial_hand = PartialWinningHand {
            melds: Vec::new(),
            pair_tile: None,
        };

        assert!(!_hand_grouping(&tiles, &partial_hand).is_some());

        // add winning tile: 5p
        tiles.push(String::from("5p"));

        let grouping_result = _hand_grouping(&tiles, &partial_hand);
        assert!(grouping_result.is_some());
        assert_eq!(grouping_result.as_ref().unwrap().len(), 1);
    }

    #[test]
    fn test_hand_grouping_little_winds() {
        // Three groups (triplets or quads) of different winds, and a pair of the fourth
        // From https://riichi.wiki/List_of_yaku (Shousuushii)
        let mut tiles = Vec::from([
            String::from("8m"),
            String::from("8m"),
            String::from("8m"),
            String::from("Ew"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Sw"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Ww"),
            String::from("Nw"),
            String::from("Nw"),
            String::from("Nw"),
        ]);

        let partial_hand = PartialWinningHand {
            melds: Vec::new(),
            pair_tile: None,
        };

        assert!(!_hand_grouping(&tiles, &partial_hand).is_some());

        // add winning tile: Ew
        tiles.push(String::from("Ew"));

        let grouping_result = _hand_grouping(&tiles, &partial_hand);
        assert!(grouping_result.is_some());
        assert_eq!(grouping_result.as_ref().unwrap().len(), 1);
    }

    #[test]
    fn test_hand_grouping_nine_gates() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("1m"),
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("9m"),
            String::from("9m"),
        ]);
        for rank in 1..=9 {
            let mut new_tiles = tiles.clone();
            let mut added_tile = String::from(rank.to_string());
            added_tile.push('m');
            new_tiles.push(added_tile);

            let partial_hand = PartialWinningHand {
                melds: Vec::new(),
                pair_tile: None,
            };
            let grouping_result = _hand_grouping(&new_tiles, &partial_hand);
            assert!(grouping_result.is_some());
            // TODO fix code to pass this test: need to de-dupe winning hands
            assert_eq!(grouping_result.as_ref().unwrap().len(), 1);
            println!("- nine gates variation winning hand: {:?}", grouping_result.unwrap().get(0).unwrap());
        }
    }

    #[test]
    fn test_remove_one_copy() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("9m"),
        ]);

        let tile_to_remove = "9m".to_string();
        let remaining_tiles = _remove_one_copy(&tiles, &tile_to_remove);
        println!("{:?}", remaining_tiles);
        assert_eq!(remaining_tiles.len(), tiles.len() - 1);

        let new_tiles_count_by_suit = count_tiles_by_suit_rank(&remaining_tiles);
        assert!(new_tiles_count_by_suit.get("m").unwrap().get("9") == Some(&1));
    }

    #[test]
    fn test_remove_one_copy_none_exists() {
        let tiles = Vec::from([
            String::from("1m"),
            String::from("2m"),
            String::from("3m"),
            String::from("4m"),
            String::from("5m"),
            String::from("6m"),
            String::from("7m"),
            String::from("8m"),
            String::from("9m"),
            String::from("9m"),
        ]);

        let tile_to_remove = "1s".to_string();
        let remaining_tiles = _remove_one_copy(&tiles, &tile_to_remove);
        assert_eq!(remaining_tiles.len(), tiles.len());
    }
}
