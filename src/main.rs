use std::collections::HashMap;
pub mod tiles;

pub fn count_tiles_by_suit_rank(
    tiles: &Vec<tiles::Tile>,
    ignore_red_fives: bool, // treat red fives the same as normal fives
) -> HashMap<tiles::TileSuit, HashMap<tiles::TileRank, u32>> {
    // build frequency count per tile suit: mapping of tile suit -> (mapping of rank -> count)
    let mut tile_counts_by_suit: HashMap<tiles::TileSuit, HashMap<tiles::TileRank, u32>> =
        HashMap::new();
    /* section adapted from result from prompt to ChatGPT Mar 23 version:
     * prompt:
     * Write a program in Rust that takes in a Vector<String> where each element is a 2-character ASCII string,
     * and returns a HashMap<&str, HashMap<&str, i32>> that contains the counts of each (first character, second
     * character) pair in the input Vector, grouped by the outer key.
     * Example input: [String::from("a1"), String::from("a1"), String::from("a2"), String::from("b2")]
     * Example output: {"a": {"1": 2, "2": 1}, "b": {"2": 1}}
     */
    for tile in tiles.iter() {
        let inner_map: &mut HashMap<tiles::TileRank, u32> = tile_counts_by_suit
            .entry(tile.suit())
            .or_insert_with(HashMap::new);
        let mut rank = tile.rank();
        if ignore_red_fives && rank == tiles::TileRank::Number(tiles::NumberTileRank::RedFive) {
            rank = tiles::TileRank::Number(tiles::NumberTileRank::Five);
        }
        let rank = rank;
        *inner_map.entry(rank).or_insert(0) += 1;
    }
    // end section generated by ChatGPT

    tile_counts_by_suit
}

pub fn get_pair_group(tile_groups: &Vec<tiles::TileGroup>) -> Option<tiles::Tile> {
    for tile_group in tile_groups {
        match *tile_group {
            tiles::TileGroup::Pair { tiles } => {
                return Some(tiles[0]);
            }
            _ => {}
        }
    }
    return None;
}

pub fn first_copy_index(
    tiles: &Vec<tiles::Tile>,
    tile_rank: tiles::TileRank,
    tile_suit: tiles::TileSuit,
    ignore_red_fives: bool, // treat red fives the same as normal fives
) -> Option<usize> {
    // println!("tile_rank to find: {:?}, tile_suit to find: {:?}", tile_rank, tile_suit);
    for tile_idx in 0..tiles.len() {
        let tile = tiles
            .get(tile_idx)
            .expect("Vector should include this index");
        // println!("tile: {:?}", tile.to_string());

        if tile.suit() == tile_suit {
            if tile.rank() == tile_rank {
                return Some(tile_idx);
            } else if ignore_red_fives
                && tile.rank() == tiles::TileRank::Number(tiles::NumberTileRank::RedFive)
            {
                return Some(tile_idx);
            }
        }
    }
    None
}

pub fn remove_first_copy(
    tiles: Vec<tiles::Tile>,
    tile_rank: tiles::TileRank,
    tile_suit: tiles::TileSuit,
    ignore_red_fives: bool, // treat red fives the same as normal fives
) -> (Vec<tiles::Tile>, Option<tiles::Tile>) {
    let found_idx: Option<usize> = first_copy_index(&tiles, tile_rank, tile_suit, ignore_red_fives);
    match found_idx {
        Some(index_to_remove) => {
            let mut new_tiles = tiles.clone();
            let removed_tile = new_tiles
                .get(index_to_remove)
                .expect("Index to remove should be valid in vec")
                .clone();
            new_tiles.swap_remove(index_to_remove);
            (new_tiles, Some(removed_tile))
        }
        None => (tiles, None),
    }
}

pub fn hand_grouping(
    tiles: &Vec<tiles::Tile>,
    hand_groups: &Vec<tiles::TileGroup>,
) -> Option<Vec<Vec<tiles::TileGroup>>> {
    // returns Some if the remaining tiles can be grouped (three of a kind, four of a kind, or a sequence) and exactly one pair
    // can return multiple values if there are multiple valid groupings
    // TODO is this possible?

    // example: if the parameter partial_hand contains a pair already, and the only way to use a tile is in a pair, then this function would return none

    println!("{} remaining tiles: {:?}", tiles.len(), tiles);

    if tiles.is_empty() {
        // println!("partial hand so far:");
        // println!("pair tile: {:?}", get_pair_group(hand_groups));
        // println!("melds: {:?}", hand_groups);
        if get_pair_group(hand_groups).is_some() && hand_groups.len() == 5 {
            println!("found winning hand: {:?}", hand_groups);
            return Some(vec![hand_groups.to_vec()]);
        } else {
            println!(
                "invalid hand with no tiles remaining, num melds = {}, pair_tile = {:?}",
                hand_groups.len(),
                get_pair_group(hand_groups)
            );
            return None;
        }
    }
    if tiles.len() == 1 {
        // println!(
        //     "invalid grouping: only one tile left {}",
        //     tiles.get(0).expect("should be one tile left")
        // );
        return None;
    }
    if tiles.len() == 2 {
        // if there are only two tiles left, the only way this can be a winning hand is if
        // the remaining tiles form the pair
        let candidate_pair = tiles::TileGroup::Pair {
            tiles: [tiles[0], tiles[1]],
        };
        if !candidate_pair.is_valid() {
            // invalid pair (i.e. not the same tile rank and suit) -> not winning hand
            println!("invalid grouping: last two tiles aren't a pair");
            return None;
        }
        if get_pair_group(hand_groups).is_some() {
            // already has a pair -> not winning hand
            println!("invalid grouping: already have one pair");
            return None;
        }
        let mut new_groups = hand_groups.to_vec();
        new_groups.push(candidate_pair);
        println!("found winning hand: {:?}", new_groups);
        return Some(vec![new_groups]);
    }

    // this works with partial hand states e.g. excluding tiles from open melds, and when working recursively
    let remaining_tiles = tiles.clone();

    // count red-five tiles along with normal five tiles
    // e.g. 4m 0m 6m is a sequence, just like 4m 5m 6m
    let tile_counts_by_suit = count_tiles_by_suit_rank(&remaining_tiles, true);

    // check honor tiles:
    // - any isolated honors? if so, not winning
    // - if there is a pair, that must be the only pair in the hand
    let honor_suit = tiles::TileSuit::Honor;
    if let Some(honor_counts) = tile_counts_by_suit.get(&honor_suit) {
        for (tile_rank, tile_count) in honor_counts {
            let considered_tile = tiles::Tile::from_suit_and_rank(honor_suit, *tile_rank, 0);
            let considered_tile_str = considered_tile.to_string();

            if tile_count == &0 {
                continue;
            }
            if tile_count == &1 {
                // isolated honor tile -> not winning hand
                println!("isolated honor tile {considered_tile_str}");
                return None;
            } else if tile_count == &2 {
                if get_pair_group(hand_groups).is_some() {
                    // honor tile must be the pair, but can only have one pair in the winning hand
                    println!("pair of honor tile {considered_tile_str} but already have a pair");
                    return None;
                } else {
                    // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                    // no way for a single honor tile type to be used in more than one meld/group

                    // TODO improve the logic here
                    // remove the pair of tiles from the vec
                    let mut remaining_tiles = tiles.clone();
                    let mut removed_tiles = Vec::new();
                    for _copies in 0..2 {
                        for (tile_index, tile) in remaining_tiles.iter().enumerate() {
                            if tile.suit() == honor_suit && tile.rank() == *tile_rank {
                                removed_tiles.push(tile.clone());
                                remaining_tiles.swap_remove(tile_index);
                                break;
                            }
                        }
                    }
                    // println!("found pair of {}, remaining tiles: {:?}", considered_tile_str, remaining_tiles);

                    // create the new pair group with the correct tiles
                    let pair_group = tiles::TileGroup::Pair {
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                        ],
                    };
                    assert!(pair_group.is_valid());

                    let mut new_groups = hand_groups.clone();
                    new_groups.push(pair_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return hand_grouping(&remaining_tiles, &new_groups);
                }
            } else if tile_count == &3 || tile_count == &4 {
                // a triplet or a quad

                // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                // no way for a single honor tile type to be used in more than one meld/group

                // TODO improve the logic here
                // remove the tiles from the vec
                let mut remaining_tiles = tiles.clone();
                let mut removed_tiles = Vec::new();
                for _copies in 0..*tile_count {
                    for (tile_index, tile) in remaining_tiles.iter().enumerate() {
                        if tile.suit() == honor_suit && tile.rank() == *tile_rank {
                            removed_tiles.push(tile.clone());
                            remaining_tiles.swap_remove(tile_index);
                            break;
                        }
                    }
                }
                // println!("found set of {}, remaining tiles: {:?}", considered_tile_str, remaining_tiles);

                // create the new group with the correct tiles
                if removed_tiles.len() == 3 {
                    let triplet_group = tiles::TileGroup::Triplet {
                        open: false,
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                            *(removed_tiles
                                .get(2)
                                .expect("Should have removed at least three tiles")),
                        ],
                    };
                    assert!(triplet_group.is_valid());

                    let mut new_groups = hand_groups.clone();
                    new_groups.push(triplet_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return hand_grouping(&remaining_tiles, &new_groups);
                } else if removed_tiles.len() == 4 {
                    let quad_group = tiles::TileGroup::Quad {
                        open: false,
                        added: false,
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                            *(removed_tiles
                                .get(2)
                                .expect("Should have removed at least three tiles")),
                            *(removed_tiles
                                .get(3)
                                .expect("Should have removed at least four tiles")),
                        ],
                    };
                    assert!(quad_group.is_valid());

                    let mut new_groups = hand_groups.clone();
                    new_groups.push(quad_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return hand_grouping(&remaining_tiles, &new_groups);
                } else {
                    panic!("Should have only three or four tiles!");
                }
            } else {
                println!("impossible, cannot be more than 4 tiles!");
                return None;
            }
        }
    }

    // check number suits
    for tile_suit in [
        tiles::TileSuit::Man,
        tiles::TileSuit::Pin,
        tiles::TileSuit::Sou,
    ] {
        if let Some(tile_counts) = tile_counts_by_suit.get(&tile_suit) {
            // TODO why consider all of the ranks one by one? why not just consider only tile ranks with count > 0, sorted in ascending order
            for rank in 1..=9 {
                let tile_rank = tiles::TileRank::Number(
                    tiles::NumberTileRank::try_from(
                        char::from_digit(rank, 10).expect("Valid rank integer for char"),
                    )
                    .expect("valid tile rank"),
                );
                // println!(
                //     "considering tile {}{}",
                //     char::from(tile_rank),
                //     char::from(tile_suit)
                // );

                let tile_count = tile_counts.get(&tile_rank).unwrap_or(&0);
                let tile_count = *tile_count;

                if tile_count == 0 {
                    continue;
                }

                let mut winning_hands: Vec<Vec<tiles::TileGroup>> = Vec::new();
                if tile_count >= 1 && rank <= 7 {
                    // single number tile can be used for sequence

                    // check for presence of higher rank tiles
                    // TODO refactor?
                    let second_rank = rank + 1;
                    let third_rank = rank + 2;
                    // need to ensure that second_rank and third_rank are <= 9
                    let second_tile_rank = tiles::NumberTileRank::try_from(
                        char::from_digit(second_rank, 10).expect("Valid rank integer for char"),
                    );
                    let third_tile_rank = tiles::NumberTileRank::try_from(
                        char::from_digit(third_rank, 10).expect("Valid rank integer for char"),
                    );

                    if second_tile_rank.is_ok()
                        && third_tile_rank.is_ok()
                        && tile_counts
                            .get(
                                &(tiles::TileRank::Number(
                                    second_tile_rank.expect("Result should not be Err!"),
                                )),
                            )
                            .unwrap_or(&0)
                            > &0
                        && tile_counts
                            .get(
                                &(tiles::TileRank::Number(
                                    third_tile_rank.expect("Result should not be Err!"),
                                )),
                            )
                            .unwrap_or(&0)
                            > &0
                    {
                        // println!("checking for sequence starting at {}{}", char::from(tile_rank), char::from(tile_suit));
                        let second_tile_rank = tiles::TileRank::Number(
                            second_tile_rank.expect("Result should not be Err!"),
                        );
                        let third_tile_rank = tiles::TileRank::Number(
                            third_tile_rank.expect("Result should not be Err!"),
                        );

                        // build remaining tiles by removing one copy of each of the three tiles in the sequence
                        let remaining_tiles = tiles.clone();
                        let (remaining_tiles, removed_first_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                        let (remaining_tiles, removed_second_tile) =
                            remove_first_copy(remaining_tiles, second_tile_rank, tile_suit, true);
                        let (remaining_tiles, removed_third_tile) =
                            remove_first_copy(remaining_tiles, third_tile_rank, tile_suit, true);
                        let mut removed_tiles = Vec::new();
                        match removed_first_tile {
                            Some(removed_first_tile) => removed_tiles.push(removed_first_tile),
                            None => panic!("Expected to remove a tile!"),
                        };
                        match removed_second_tile {
                            Some(removed_second_tile) => removed_tiles.push(removed_second_tile),
                            None => panic!("Expected to remove a tile!"),
                        };
                        match removed_third_tile {
                            Some(removed_third_tile) => removed_tiles.push(removed_third_tile),
                            None => panic!("Expected to remove a tile!"),
                        };

                        // new group
                        let new_sequence_group = tiles::TileGroup::Sequence {
                            open: false,
                            tiles: [
                                removed_first_tile.expect("Should have removed at least one tile"),
                                removed_second_tile
                                    .expect("Should have removed at least two tiles"),
                                removed_third_tile
                                    .expect("Should have removed at least three tiles"),
                            ],
                        };

                        // if any existing winning hands use this sequence, you may still need to make this recursive call
                        // e.g. for a hand with two identical sequences (e.g. 334455m, a valid winning hand will include multiple
                        // identical melds)

                        // recursive call
                        let mut new_groups = hand_groups.clone();
                        new_groups.push(new_sequence_group);
                        println!(
                            "recursive call: using sequence starting at {}{}",
                            char::from(tile_rank),
                            char::from(tile_suit)
                        );

                        if let Some(new_winning_hands) =
                            hand_grouping(&remaining_tiles, &new_groups)
                        {
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }
                if tile_count >= 2 {
                    // two copies of number tile can be used for pair

                    // make sure there is no existing tile marked as pair
                    if !get_pair_group(hand_groups).is_some() {
                        // build remaining tiles by removing two copies of the tile
                        let remaining_tiles = tiles.clone();
                        let (remaining_tiles, removed_first_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                        let (remaining_tiles, removed_second_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                        let mut removed_tiles = Vec::new();
                        match removed_first_tile {
                            Some(removed_first_tile) => removed_tiles.push(removed_first_tile),
                            None => panic!("Expected to remove a tile!"),
                        };
                        match removed_second_tile {
                            Some(removed_second_tile) => removed_tiles.push(removed_second_tile),
                            None => panic!("Expected to remove a tile!"),
                        };

                        // new group
                        let new_pair_group = tiles::TileGroup::Pair {
                            tiles: [
                                removed_first_tile.expect("Should have removed at least one tile"),
                                removed_second_tile
                                    .expect("Should have removed at least two tiles"),
                            ],
                        };
                        // println!("found pair of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);

                        // if any existing winning hands use a pair of this tile, don't make this recursive call!
                        // otherwise you'll end up with duplicated winning hands
                        let has_winning_hand_with_this_pair = winning_hands
                            .iter()
                            .filter(|&winning_hand|
                            // does this WinningHand include a tiles::TileGroup::Pair of this tile?
                            match get_pair_group(winning_hand) {
                                Some(existing_pair_tile) => existing_pair_tile.rank() == tile_rank && existing_pair_tile.suit() == tile_suit,
                                None => false,
                            })
                            .next()
                            .is_some();

                        if !has_winning_hand_with_this_pair {
                            // recursive call
                            println!(
                                "recursive call: using pair of {}{}",
                                char::from(tile_rank),
                                char::from(tile_suit)
                            );

                            let mut new_groups = hand_groups.clone();
                            new_groups.push(new_pair_group);

                            if let Some(new_winning_hands) =
                                hand_grouping(&remaining_tiles, &new_groups)
                            {
                                winning_hands.extend(new_winning_hands);
                            }
                        }
                    }
                }
                if tile_count >= 3 {
                    // three copies of number tile can be used for triplet
                    // println!("checking for triplet of {new_tile_str}");

                    // build remaining tiles by removing three copies of the tile
                    let remaining_tiles = tiles.clone();
                    let (remaining_tiles, removed_first_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_second_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_third_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let mut removed_tiles = Vec::new();
                    match removed_first_tile {
                        Some(removed_first_tile) => removed_tiles.push(removed_first_tile),
                        None => panic!("Expected to remove a tile!"),
                    };
                    match removed_second_tile {
                        Some(removed_second_tile) => removed_tiles.push(removed_second_tile),
                        None => panic!("Expected to remove a tile!"),
                    };
                    match removed_third_tile {
                        Some(removed_third_tile) => removed_tiles.push(removed_third_tile),
                        None => panic!("Expected to remove a tile!"),
                    };

                    // new group
                    let new_triplet_group = tiles::TileGroup::Triplet {
                        open: false,
                        tiles: [
                            removed_first_tile.expect("Should have removed at least one tile"),
                            removed_second_tile.expect("Should have removed at least two tiles"),
                            removed_third_tile.expect("Should have removed at least three tiles"),
                        ],
                    };

                    // if any existing winning hands use a triplet of this tile, don't make this recursive call!
                    // otherwise you'll end up with duplicated winning hands
                    let has_winning_hand_with_triplet = winning_hands
                        .iter()
                        .filter(|&winning_hand|
                        // does this WinningHand include a HandMeld that is a triplet of this tile?
                        (*winning_hand).iter().filter(|&meld|
                            match *meld {
                                tiles::TileGroup::Triplet { tiles, .. } => tiles[0].suit() == tile_suit && tiles[0].rank() == tile_rank,
                                _ => false,
                            }
                        ).next().is_some())
                        .next()
                        .is_some();

                    if !has_winning_hand_with_triplet {
                        // recursive call
                        println!(
                            "recursive call: using triplet of {}{}",
                            char::from(tile_rank),
                            char::from(tile_suit)
                        );

                        let mut new_groups = hand_groups.clone();
                        new_groups.push(new_triplet_group);

                        if let Some(new_winning_hands) =
                            hand_grouping(&remaining_tiles, &new_groups)
                        {
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }
                if tile_count >= 4 {
                    // three copies of number tile can be used for quad
                    // println!("checking for quad of {new_tile_str}");

                    // build remaining tiles by remtest_count_tiles_by_suit_rank_red_fivesoving four copies of the tile
                    let remaining_tiles = tiles.clone();
                    let (remaining_tiles, removed_first_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_second_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_third_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_fourth_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let mut removed_tiles = Vec::new();
                    match removed_first_tile {
                        Some(removed_first_tile) => removed_tiles.push(removed_first_tile),
                        None => panic!("Expected to remove a tile!"),
                    };
                    match removed_second_tile {
                        Some(removed_second_tile) => removed_tiles.push(removed_second_tile),
                        None => panic!("Expected to remove a tile!"),
                    };
                    match removed_third_tile {
                        Some(removed_third_tile) => removed_tiles.push(removed_third_tile),
                        None => panic!("Expected to remove a tile!"),
                    };
                    match removed_fourth_tile {
                        Some(removed_fourth_tile) => removed_tiles.push(removed_fourth_tile),
                        None => panic!("Expected to remove a tile!"),
                    };

                    // new group
                    let new_quad_group = tiles::TileGroup::Quad {
                        open: false,
                        added: false,
                        tiles: [
                            removed_first_tile.expect("Should have removed at least one tile"),
                            removed_second_tile.expect("Should have removed at least two tiles"),
                            removed_third_tile.expect("Should have removed at least three tiles"),
                            removed_fourth_tile.expect("Should have removed at least four tiles"),
                        ],
                    };

                    // if any existing winning hands use a quad of this tile, don't make this recursive call!
                    // otherwise you'll end up with duplicated winning hands
                    let has_winning_hand_with_quad = winning_hands
                        .iter()
                        .filter(|&winning_hand|
                        // does this WinningHand include a HandMeld that is a quad of this tile?
                        (*winning_hand).iter().filter(|&meld|
                            match *meld {
                                tiles::TileGroup::Quad { tiles, .. } => tiles[0].suit() == tile_suit && tiles[0].rank() == tile_rank,
                                _ => false,
                            }
                        ).next().is_some())
                        .next()
                        .is_some();

                    if !has_winning_hand_with_quad {
                        // recursive call
                        println!(
                            "recursive call: using quad of {}{}",
                            char::from(tile_rank),
                            char::from(tile_suit)
                        );

                        let mut new_groups = hand_groups.clone();
                        new_groups.push(new_quad_group);

                        if let Some(new_winning_hands) =
                            hand_grouping(&remaining_tiles, &new_groups)
                        {
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }

                // we have to use this tile in the winning hand somehow - if there's no winning hands at this point,
                // then there are no winning hands at all
                return if winning_hands.is_empty() {
                    println!(
                        "invalid grouping: could not use tile {}{}",
                        char::from(tile_rank),
                        char::from(tile_suit)
                    );
                    None
                } else {
                    Some(winning_hands)
                };
            }
        }
    }

    println!("invalid grouping: no more tiles");
    return None;
}

fn main() {
    for serial in 0..tiles::NUM_TILES {
        let tile = tiles::Tile { serial };
        // print!("{} ", tile.to_string());
        print!("{} ", tile.to_human_string());
        if (serial < 3 * 36 && serial % 9 == 8) || (serial >= 3 * 36 && (serial - 3 * 36) % 7 == 6)
        {
            println!("");
        }
    }
}

#[cfg(test)]
mod tests {
    // importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_count_tiles_by_suit_rank() {
        let tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("6z"), // green dragon
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("3z"), // west wind
            tiles::Tile::from_string("3z"),
            tiles::Tile::from_string("3z"),
        ]);

        let counts = count_tiles_by_suit_rank(&tiles, true);
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::One)),
            Some(&3)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Two)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Three)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Four)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Eight)),
            Some(&2)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Honor)
                .unwrap()
                .get(&tiles::TileRank::Honor(tiles::HonorTileRank::Green)),
            Some(&2)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Honor)
                .unwrap()
                .get(&tiles::TileRank::Honor(tiles::HonorTileRank::West)),
            Some(&3)
        );
    }

    #[test]
    fn test_count_tiles_by_suit_rank_red_fives() {
        let tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("0m"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("0p"),
        ]);

        let counts = count_tiles_by_suit_rank(&tiles, true);
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::One)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&3)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            None
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Sou)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&3)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Sou)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            None
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Pin)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Pin)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            None
        );

        let counts_separate_red_fives = count_tiles_by_suit_rank(&tiles, false);
        assert_eq!(
            counts_separate_red_fives
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&2)
        );
        assert_eq!(
            counts_separate_red_fives
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            Some(&1)
        );
    }

    // winning hands taken from my Mahjong Soul logs
    // game: 4-player East round, Silver room, 2023-06-03 09:26
    #[test]
    fn test_hand_grouping_1() {
        // round: East 1 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 3 han, 40 fu = 5200 pts (riichi, ippatsu, dora x1 (3m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("3m"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_2() {
        // round: East 2 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 3 han, 40 fu = 5200 pts (riichi, red five x1, ura dora x1 (4m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("0m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("7m"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_3() {
        // round: East 3 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 4 han, 40 fu = mangan (8000 pts) (riichi, pure double sequence, red five x1, ura dora x1 (2m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("0m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6z"), // green dragon
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("4p"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_4() {
        // round: East 4 (0 repeat), winning hand by West (open hand, ron)
        // scoring: 4 han, 30 fu = 7700 pts (white dragon, dora x3 (7m, 8p))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("5z"), // white dragon
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("2m"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = vec![
            tiles::TileGroup::Sequence {
                open: true,
                tiles: [
                    tiles::Tile::from_string("4s"),
                    tiles::Tile::from_string("5s"),
                    tiles::Tile::from_string("3s"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                ],
            },
        ];
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    // winning hands taken from my Mahjong Soul logs
    // game: 4-player East round, Silver room,
    #[test]
    fn test_hand_grouping_5() {
        // round: East 1 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 5 han, 40 fu = mangan (8000 pts) (riichi, mixed triple sequence, red five x1)
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("0p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("1s"),
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("4p"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_6() {
        // round: East 2 (1 repeat), winning hand by East (riichi, ron)
        // scoring: 2 han, 40 fu = 2600 pts (riichi, ura dora x1 (4m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("9s"),
            tiles::Tile::from_string("7s"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_7() {
        // round: East 3 (1 repeat), winning hand by North (riichi, ron)
        // scoring: 3 han, 30 fu = 3900 pts (riichi, pinfu, ura dora x1 (3p))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("1m"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_8() {
        // round: East 4 (0 repeat), winning hand by North (open hand, ron)
        // scoring: 2 han, 30 fu = 2000 pts (all simples, red five x1)
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("5p"), // TODO is this supposed to be a 4p tile?
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("0s"),
            tiles::Tile::from_string("4s"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = vec![
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("6p"),
                    tiles::Tile::from_string("6p"),
                    tiles::Tile::from_string("6p"),
                ],
            },
            tiles::TileGroup::Sequence {
                open: true,
                tiles: [
                    tiles::Tile::from_string("4m"),
                    tiles::Tile::from_string("5m"),
                    tiles::Tile::from_string("3m"),
                ],
            },
        ];
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_9() {
        // round: East 4 (0 repeat), winning hand by East (open hand, ron)
        // scoring: 3 han, 30 fu = 5800 pts (all simples, all triplets)
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = vec![
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("8m"),
                    tiles::Tile::from_string("8m"),
                    tiles::Tile::from_string("8m"),
                ],
            },
        ];
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        assert!(
            winning_hand_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_hand_grouping_multiple_groupings() {
        // example of hand with multiple valid winning groupings (scoring needs to consider which grouping produces the
        // highest score, prioritizing higher han value, then higher fu value)
        // example hand from: https://riichi.wiki/Fu#Maximal_Score
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("9m"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("9s"),
        ]);

        let hand_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_hand_groups = hand_grouping(&winning_tiles, &hand_groups);
        assert!(winning_hand_groups.is_some());
        let winning_hand_groups = winning_hand_groups.expect("Expect some winning groupings");
        assert!(winning_hand_groups.len() == 2);

        // the pair is either the 6p or the 9p
        let first_winning_grouping = winning_hand_groups
            .get(0)
            .expect("Expect two winning groupings");
        let second_winning_grouping = winning_hand_groups
            .get(1)
            .expect("Expect two winning groupings");
        let grouping_pair_tiles = [
            get_pair_group(&first_winning_grouping)
                .expect("winning grouping must have a pair")
                .to_string(),
            get_pair_group(&second_winning_grouping)
                .expect("winning grouping must have a pair")
                .to_string(),
        ];
        assert!(
            grouping_pair_tiles.contains(&String::from("6p"))
                && grouping_pair_tiles.contains(&String::from("9p"))
        );
    }
}
