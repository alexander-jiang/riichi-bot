use crate::tiles;
use std::collections::HashMap;

pub fn count_tiles_by_suit_rank(
    tiles: &Vec<tiles::Tile>,
    ignore_red_fives: bool, // treat red fives the same as normal fives
) -> HashMap<tiles::TileSuit, HashMap<tiles::TileRank, u32>> {
    // build frequency count per tile suit: mapping of tile suit -> (mapping of rank -> count)
    let mut tile_counts_by_suit: HashMap<tiles::TileSuit, HashMap<tiles::TileRank, u32>> =
        HashMap::new();
    /* section adapted from result from prompt to ChatGPT Mar 23 version:
     * prompt:
     * Write a program in Rust that takes in a Vector<String> where each element is a 2-character ASCII string,
     * and returns a HashMap<&str, HashMap<&str, i32>> that contains the counts of each (first character, second
     * character) pair in the input Vector, grouped by the outer key.
     * Example input: [String::from("a1"), String::from("a1"), String::from("a2"), String::from("b2")]
     * Example output: {"a": {"1": 2, "2": 1}, "b": {"2": 1}}
     */
    for tile in tiles.iter() {
        let inner_map: &mut HashMap<tiles::TileRank, u32> = tile_counts_by_suit
            .entry(tile.suit())
            .or_insert_with(HashMap::new);
        let mut rank = tile.rank();
        if ignore_red_fives && rank == tiles::TileRank::Number(tiles::NumberTileRank::RedFive) {
            rank = tiles::TileRank::Number(tiles::NumberTileRank::Five);
        }
        let rank = rank;
        *inner_map.entry(rank).or_insert(0) += 1;
    }
    // end section generated by ChatGPT

    tile_counts_by_suit
}

pub fn first_copy_index(
    tiles: &Vec<tiles::Tile>,
    tile_rank: tiles::TileRank,
    tile_suit: tiles::TileSuit,
    ignore_red_fives: bool, // treat red fives the same as normal fives
) -> Option<usize> {
    // println!("tile_rank to find: {:?}, tile_suit to find: {:?}", tile_rank, tile_suit);
    for tile_idx in 0..tiles.len() {
        let tile = tiles
            .get(tile_idx)
            .expect("Vector should include this index");
        // println!("tile: {:?}", tile.to_string());

        if tile.suit() == tile_suit {
            if tile.rank() == tile_rank {
                return Some(tile_idx);
            } else if ignore_red_fives
                && tile.rank() == tiles::TileRank::Number(tiles::NumberTileRank::RedFive)
            {
                return Some(tile_idx);
            }
        }
    }
    None
}

pub fn remove_first_copy(
    tiles: Vec<tiles::Tile>,
    tile_rank: tiles::TileRank,
    tile_suit: tiles::TileSuit,
    ignore_red_fives: bool, // treat red fives the same as normal fives
) -> (Vec<tiles::Tile>, Option<tiles::Tile>) {
    let found_idx: Option<usize> = first_copy_index(&tiles, tile_rank, tile_suit, ignore_red_fives);
    match found_idx {
        Some(index_to_remove) => {
            let mut new_tiles = tiles.clone();
            let removed_tile = new_tiles
                .get(index_to_remove)
                .expect("Index to remove should be valid in vec")
                .clone();
            new_tiles.swap_remove(index_to_remove);
            (new_tiles, Some(removed_tile))
        }
        None => (tiles, None),
    }
}

// TODO check for thirteen orphans tile grouping

/// Returns Some if the tiles can be grouped into the seven pairs yaku (an exception to the standard winning hand shape of 4 melds and a pair)
pub fn seven_pairs_tile_grouping(
    tiles: &Vec<tiles::Tile>,
    tile_groups: &Vec<tiles::TileGroup>,
) -> Option<Vec<tiles::TileGroup>> {
    // seven pairs cannot contain any open groups
    if !tile_groups.is_empty() {
        return None;
    }

    let mut remaining_tiles = tiles.clone();
    let mut new_groups = Vec::new();

    let tile_counts_by_suit = count_tiles_by_suit_rank(&tiles, true);
    for (&tile_suit, counts_in_suit) in tile_counts_by_suit.iter() {
        for (&tile_rank, &count) in counts_in_suit.iter() {
            if count == 2 {
                let first_tile_idx = first_copy_index(&remaining_tiles, tile_rank, tile_suit, true)
                    .expect("expect to find tile");
                let first_tile = remaining_tiles
                    .get(first_tile_idx)
                    .expect("expect to find tile index")
                    .clone();
                remaining_tiles.swap_remove(first_tile_idx);
                let second_tile_idx =
                    first_copy_index(&remaining_tiles, tile_rank, tile_suit, true)
                        .expect("expect to find tile");
                let second_tile = remaining_tiles
                    .get(second_tile_idx)
                    .expect("expect to find tile index")
                    .clone();
                remaining_tiles.swap_remove(second_tile_idx);
                let new_group = tiles::TileGroup::Pair {
                    tiles: [first_tile, second_tile],
                };
                new_groups.push(new_group);
            } else {
                return None;
            }
        }
    }

    // there must be exactly seven pairs
    if new_groups.len() != 7 {
        return None;
    }
    Some(new_groups)
}

pub fn tile_grouping(
    tiles: &Vec<tiles::Tile>,
    tile_groups: &Vec<tiles::TileGroup>,
) -> Option<Vec<Vec<tiles::TileGroup>>> {
    // returns Some if the remaining tiles can be grouped (three of a kind, four of a kind, or a sequence) and exactly one pair
    // can return multiple values if there are multiple valid groupings
    // TODO is this possible?

    // example: if the parameter partial_hand contains a pair already, and the only way to use a tile is in a pair, then this function would return none

    println!("{} remaining tiles: {:?}", tiles.len(), tiles);

    if tiles.is_empty() {
        // println!("partial hand so far:");
        // println!("pair tile: {:?}", tiles::get_pair_group(hand_groups));
        // println!("melds: {:?}", hand_groups);
        if tiles::get_pair_group(tile_groups).is_some() && tile_groups.len() == 5 {
            println!("found winning hand: {:?}", tile_groups);
            return Some(vec![tile_groups.to_vec()]);
        } else {
            println!(
                "invalid hand with no tiles remaining, num melds = {}, pair_tile = {:?}",
                tile_groups.len(),
                tiles::get_pair_group(tile_groups)
            );
            return None;
        }
    }
    if tiles.len() == 1 {
        // println!(
        //     "invalid grouping: only one tile left {}",
        //     tiles.get(0).expect("should be one tile left")
        // );
        return None;
    }
    if tiles.len() == 2 {
        // if there are only two tiles left, the only way this can be a winning hand is if
        // the remaining tiles form the pair
        let candidate_pair = tiles::TileGroup::Pair {
            tiles: [tiles[0], tiles[1]],
        };
        if !candidate_pair.is_valid() {
            // invalid pair (i.e. not the same tile rank and suit) -> not winning hand
            println!("invalid grouping: last two tiles aren't a pair");
            return None;
        }
        if tiles::get_pair_group(tile_groups).is_some() {
            // already has a pair -> not winning hand
            println!("invalid grouping: already have one pair");
            return None;
        }
        let mut new_groups = tile_groups.to_vec();
        new_groups.push(candidate_pair);
        println!("found winning hand: {:?}", new_groups);
        return Some(vec![new_groups]);
    }

    // this works with partial hand states e.g. excluding tiles from open melds, and when working recursively
    let remaining_tiles = tiles.clone();

    // count red-five tiles along with normal five tiles
    // e.g. 4m 0m 6m is a sequence, just like 4m 5m 6m
    let tile_counts_by_suit = count_tiles_by_suit_rank(&remaining_tiles, true);

    // check honor tiles:
    // - any isolated honors? if so, not winning
    // - if there is a pair, that must be the only pair in the hand
    let honor_suit = tiles::TileSuit::Honor;
    if let Some(honor_counts) = tile_counts_by_suit.get(&honor_suit) {
        for (tile_rank, tile_count) in honor_counts {
            let considered_tile = tiles::Tile::from_suit_and_rank(honor_suit, *tile_rank, 0);
            let considered_tile_str = considered_tile.to_string();

            if tile_count == &0 {
                continue;
            }
            if tile_count == &1 {
                // isolated honor tile -> not winning hand
                println!("isolated honor tile {considered_tile_str}");
                return None;
            } else if tile_count == &2 {
                if tiles::get_pair_group(tile_groups).is_some() {
                    // honor tile must be the pair, but can only have one pair in the winning hand
                    println!("pair of honor tile {considered_tile_str} but already have a pair");
                    return None;
                } else {
                    // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                    // no way for a single honor tile type to be used in more than one meld/group

                    // TODO improve the logic here
                    // remove the pair of tiles from the vec
                    let mut remaining_tiles = tiles.clone();
                    let mut removed_tiles = Vec::new();
                    for _copies in 0..2 {
                        for (tile_index, tile) in remaining_tiles.iter().enumerate() {
                            if tile.suit() == honor_suit && tile.rank() == *tile_rank {
                                removed_tiles.push(tile.clone());
                                remaining_tiles.swap_remove(tile_index);
                                break;
                            }
                        }
                    }
                    // println!("found pair of {}, remaining tiles: {:?}", considered_tile_str, remaining_tiles);

                    // create the new pair group with the correct tiles
                    let pair_group = tiles::TileGroup::Pair {
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                        ],
                    };
                    assert!(pair_group.is_valid());

                    let mut new_groups = tile_groups.clone();
                    new_groups.push(pair_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return tile_grouping(&remaining_tiles, &new_groups);
                }
            } else if tile_count == &3 || tile_count == &4 {
                // a triplet or a quad

                // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                // no way for a single honor tile type to be used in more than one meld/group

                // TODO improve the logic here
                // remove the tiles from the vec
                let mut remaining_tiles = tiles.clone();
                let mut removed_tiles = Vec::new();
                for _copies in 0..*tile_count {
                    for (tile_index, tile) in remaining_tiles.iter().enumerate() {
                        if tile.suit() == honor_suit && tile.rank() == *tile_rank {
                            removed_tiles.push(tile.clone());
                            remaining_tiles.swap_remove(tile_index);
                            break;
                        }
                    }
                }
                // println!("found set of {}, remaining tiles: {:?}", considered_tile_str, remaining_tiles);

                // create the new group with the correct tiles
                if removed_tiles.len() == 3 {
                    let triplet_group = tiles::TileGroup::Triplet {
                        open: false,
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                            *(removed_tiles
                                .get(2)
                                .expect("Should have removed at least three tiles")),
                        ],
                    };
                    assert!(triplet_group.is_valid());

                    let mut new_groups = tile_groups.clone();
                    new_groups.push(triplet_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return tile_grouping(&remaining_tiles, &new_groups);
                } else if removed_tiles.len() == 4 {
                    let quad_group = tiles::TileGroup::Quad {
                        open: false,
                        added: false,
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                            *(removed_tiles
                                .get(2)
                                .expect("Should have removed at least three tiles")),
                            *(removed_tiles
                                .get(3)
                                .expect("Should have removed at least four tiles")),
                        ],
                    };
                    assert!(quad_group.is_valid());

                    let mut new_groups = tile_groups.clone();
                    new_groups.push(quad_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return tile_grouping(&remaining_tiles, &new_groups);
                } else {
                    panic!("Should have only three or four tiles!");
                }
            } else {
                println!("impossible, cannot be more than 4 tiles!");
                return None;
            }
        }
    }

    // check number suits
    for tile_suit in [
        tiles::TileSuit::Man,
        tiles::TileSuit::Pin,
        tiles::TileSuit::Sou,
    ] {
        if let Some(tile_counts) = tile_counts_by_suit.get(&tile_suit) {
            // TODO why consider all of the ranks one by one? why not just consider only tile ranks with count > 0, sorted in ascending order
            for rank in 1..=9 {
                let tile_rank = tiles::TileRank::Number(
                    tiles::NumberTileRank::try_from(
                        char::from_digit(rank, 10).expect("Valid rank integer for char"),
                    )
                    .expect("valid tile rank"),
                );
                let new_tile_str = format!("{}{}", char::from(tile_rank), char::from(tile_suit));
                // println!("considering tile {}", new_tile_str);

                let tile_count = tile_counts.get(&tile_rank).unwrap_or(&0);
                let tile_count = *tile_count;

                if tile_count == 0 {
                    continue;
                }

                let mut winning_hands: Vec<Vec<tiles::TileGroup>> = Vec::new();
                if tile_count >= 1 && rank <= 7 {
                    // single number tile can be used for sequence

                    // check for presence of higher rank tiles
                    // TODO refactor?
                    let second_rank = rank + 1;
                    let third_rank = rank + 2;
                    // need to ensure that second_rank and third_rank are <= 9
                    let second_tile_rank = tiles::NumberTileRank::try_from(
                        char::from_digit(second_rank, 10).expect("Valid rank integer for char"),
                    );
                    let third_tile_rank = tiles::NumberTileRank::try_from(
                        char::from_digit(third_rank, 10).expect("Valid rank integer for char"),
                    );

                    if second_tile_rank.is_ok()
                        && third_tile_rank.is_ok()
                        && tile_counts
                            .get(
                                &(tiles::TileRank::Number(
                                    second_tile_rank.expect("Result should not be Err!"),
                                )),
                            )
                            .unwrap_or(&0)
                            > &0
                        && tile_counts
                            .get(
                                &(tiles::TileRank::Number(
                                    third_tile_rank.expect("Result should not be Err!"),
                                )),
                            )
                            .unwrap_or(&0)
                            > &0
                    {
                        // println!("checking for sequence starting at {}", new_tile_str);
                        let second_tile_rank = tiles::TileRank::Number(
                            second_tile_rank.expect("Result should not be Err!"),
                        );
                        let third_tile_rank = tiles::TileRank::Number(
                            third_tile_rank.expect("Result should not be Err!"),
                        );

                        // build remaining tiles by removing one copy of each of the three tiles in the sequence
                        let remaining_tiles = tiles.clone();
                        let (remaining_tiles, removed_first_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                        let (remaining_tiles, removed_second_tile) =
                            remove_first_copy(remaining_tiles, second_tile_rank, tile_suit, true);
                        let (remaining_tiles, removed_third_tile) =
                            remove_first_copy(remaining_tiles, third_tile_rank, tile_suit, true);

                        // new group
                        let new_sequence_group = tiles::TileGroup::Sequence {
                            open: false,
                            tiles: [
                                removed_first_tile.expect("Should have removed at least one tile"),
                                removed_second_tile
                                    .expect("Should have removed at least two tiles"),
                                removed_third_tile
                                    .expect("Should have removed at least three tiles"),
                            ],
                        };

                        // if any existing winning hands use this sequence, you may still need to make this recursive call
                        // e.g. for a hand with two identical sequences (e.g. 334455m, a valid winning hand will include multiple
                        // identical melds)

                        // recursive call
                        let mut new_groups = tile_groups.clone();
                        new_groups.push(new_sequence_group);
                        println!(
                            "recursive call: using sequence starting at {}",
                            new_tile_str
                        );

                        if let Some(new_winning_hands) =
                            tile_grouping(&remaining_tiles, &new_groups)
                        {
                            println!("found a winning hand using tile {}", new_tile_str);
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }
                if tile_count >= 2 {
                    // two copies of number tile can be used for pair

                    // make sure there is no existing tile marked as pair
                    if !tiles::get_pair_group(tile_groups).is_some() {
                        // build remaining tiles by removing two copies of the tile
                        let remaining_tiles = tiles.clone();
                        let (remaining_tiles, removed_first_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                        let (remaining_tiles, removed_second_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);

                        // new group
                        let new_pair_group = tiles::TileGroup::Pair {
                            tiles: [
                                removed_first_tile.expect("Should have removed at least one tile"),
                                removed_second_tile
                                    .expect("Should have removed at least two tiles"),
                            ],
                        };
                        // println!("found pair of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);

                        // if any existing winning hands use a pair of this tile, don't make this recursive call!
                        // otherwise you'll end up with duplicated winning hands
                        let has_winning_hand_with_this_pair = winning_hands
                            .iter()
                            .filter(|&winning_hand|
                            // does this WinningHand include a tiles::TileGroup::Pair of this tile?
                            match tiles::get_pair_group(winning_hand) {
                                Some(existing_pair_tile) => existing_pair_tile.rank() == tile_rank && existing_pair_tile.suit() == tile_suit,
                                None => false,
                            })
                            .next()
                            .is_some();

                        if !has_winning_hand_with_this_pair {
                            // recursive call
                            println!("recursive call: using pair of {}", new_tile_str);

                            let mut new_groups = tile_groups.clone();
                            new_groups.push(new_pair_group);

                            if let Some(new_winning_hands) =
                                tile_grouping(&remaining_tiles, &new_groups)
                            {
                                println!("found a winning hand using tile {}", new_tile_str);
                                winning_hands.extend(new_winning_hands);
                            }
                        }
                    }
                }
                if tile_count >= 3 {
                    // three copies of number tile can be used for triplet
                    // println!("checking for triplet of {new_tile_str}");

                    // build remaining tiles by removing three copies of the tile
                    let remaining_tiles = tiles.clone();
                    let (remaining_tiles, removed_first_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_second_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_third_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);

                    // new group
                    let new_triplet_group = tiles::TileGroup::Triplet {
                        open: false,
                        tiles: [
                            removed_first_tile.expect("Should have removed at least one tile"),
                            removed_second_tile.expect("Should have removed at least two tiles"),
                            removed_third_tile.expect("Should have removed at least three tiles"),
                        ],
                    };

                    // if any existing winning hands use a triplet of this tile, don't make this recursive call!
                    // otherwise you'll end up with duplicated winning hands
                    let has_winning_hand_with_triplet = winning_hands
                        .iter()
                        .filter(|&winning_hand|
                        // does this WinningHand include a HandMeld that is a triplet of this tile?
                        (*winning_hand).iter().filter(|&meld|
                            match *meld {
                                tiles::TileGroup::Triplet { tiles, .. } => tiles[0].suit() == tile_suit && tiles[0].rank() == tile_rank,
                                _ => false,
                            }
                        ).next().is_some())
                        .next()
                        .is_some();

                    if !has_winning_hand_with_triplet {
                        // recursive call
                        println!("recursive call: using triplet of {}", new_tile_str);

                        let mut new_groups = tile_groups.clone();
                        new_groups.push(new_triplet_group);

                        if let Some(new_winning_hands) =
                            tile_grouping(&remaining_tiles, &new_groups)
                        {
                            println!("found a winning hand using tile {}", new_tile_str);
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }
                if tile_count >= 4 {
                    // three copies of number tile can be used for quad
                    // println!("checking for quad of {new_tile_str}");

                    // build remaining tiles by remtest_count_tiles_by_suit_rank_red_fivesoving four copies of the tile
                    let remaining_tiles = tiles.clone();
                    let (remaining_tiles, removed_first_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_second_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_third_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_fourth_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);

                    // new group
                    let new_quad_group = tiles::TileGroup::Quad {
                        open: false,
                        added: false,
                        tiles: [
                            removed_first_tile.expect("Should have removed at least one tile"),
                            removed_second_tile.expect("Should have removed at least two tiles"),
                            removed_third_tile.expect("Should have removed at least three tiles"),
                            removed_fourth_tile.expect("Should have removed at least four tiles"),
                        ],
                    };

                    // if any existing winning hands use a quad of this tile, don't make this recursive call!
                    // otherwise you'll end up with duplicated winning hands
                    let has_winning_hand_with_quad = winning_hands
                        .iter()
                        .filter(|&winning_hand|
                        // does this WinningHand include a HandMeld that is a quad of this tile?
                        (*winning_hand).iter().filter(|&meld|
                            match *meld {
                                tiles::TileGroup::Quad { tiles, .. } => tiles[0].suit() == tile_suit && tiles[0].rank() == tile_rank,
                                _ => false,
                            }
                        ).next().is_some())
                        .next()
                        .is_some();

                    if !has_winning_hand_with_quad {
                        // recursive call
                        println!("recursive call: using quad of {}", new_tile_str);

                        let mut new_groups = tile_groups.clone();
                        new_groups.push(new_quad_group);

                        if let Some(new_winning_hands) =
                            tile_grouping(&remaining_tiles, &new_groups)
                        {
                            println!("found a winning hand using tile {}", new_tile_str);
                            winning_hands.extend(new_winning_hands);
                        }
                    }
                }

                // we have to use this tile in the winning hand somehow - if there's no winning hands at this point,
                // then there are no winning hands at all
                return if winning_hands.is_empty() {
                    println!("invalid grouping: could not use tile {}", new_tile_str);
                    None
                } else {
                    Some(winning_hands)
                };
            }
        }
    }

    println!("invalid grouping: no more tiles");
    return None;
}

/// counts the number of pair incomplete groups
pub fn number_pair_groups(tile_groups: &Vec<tiles::TileGroup>) -> usize {
    tile_groups
        .iter()
        .filter(|group| match group {
            tiles::TileGroup::Pair { .. } => true,
            _ => false,
        })
        .count()
}

/// counts the number of complete groups (triplets, quads, and sequences)
pub fn number_complete_groups(tile_groups: &Vec<tiles::TileGroup>) -> usize {
    tile_groups
        .iter()
        .filter(|group| group.is_complete())
        .count()
}

/// counts the number of incomplete groups (including pair, open wait, edge wait, closed wait, single-tile)
pub fn number_incomplete_groups(tile_groups: &Vec<tiles::TileGroup>) -> usize {
    tile_groups
        .iter()
        .filter(|group| !group.is_complete())
        .count()
}

/// counts the number of single-tile incomplete groups
pub fn number_single_tile_groups(tile_groups: &Vec<tiles::TileGroup>) -> usize {
    tile_groups
        .iter()
        .filter(|group| match group {
            tiles::TileGroup::SingleTile { .. } => true,
            _ => false,
        })
        .count()
}

/// counts the number of two-tile wait incomplete groups (open wait, edge wait, or closed wait, but not pairs)
pub fn number_wait_groups(tile_groups: &Vec<tiles::TileGroup>) -> usize {
    tile_groups
        .iter()
        .filter(|group| match group {
            tiles::TileGroup::EdgeWait { .. } => true,
            tiles::TileGroup::OpenWait { .. } => true,
            tiles::TileGroup::ClosedWait { .. } => true,
            _ => false,
        })
        .count()
}

pub fn get_tile_groups_string(tile_groups: &Vec<tiles::TileGroup>) -> String {
    let mut tile_groups_string = Vec::new();
    for group in tile_groups {
        tile_groups_string.push(group.to_tiles_string());
    }
    tile_groups_string.sort();
    let tile_groups_string = tile_groups_string;
    tile_groups_string.join("|")
}

pub fn get_tile_groups_strings(tile_groups_list: &Vec<Vec<tiles::TileGroup>>) -> Vec<String> {
    let mut tile_groups_strings = Vec::new();
    for tile_groups in tile_groups_list {
        let tile_groups_string: String = get_tile_groups_string(&tile_groups);
        tile_groups_strings.push(tile_groups_string);
    }
    let tile_groups_strings = tile_groups_strings;
    tile_groups_strings
}

pub fn tenpai_grouping(
    tiles: &Vec<tiles::Tile>,
    tile_groups: &Vec<tiles::TileGroup>,
) -> Option<Vec<Vec<tiles::TileGroup>>> {
    // returns Some if the remaining tiles can be grouped for tenpai
    // generally:
    // 1. three complete groups and a pair, with a fourth incomplete group that is only missing one tile
    // 2. four complete groups and a single tile
    // 3. six pairs and a single tile
    // 4. twelve different terminals and honors, one of which is paired
    // 5. thirteen different terminals and honors, none of which is paired

    // TODO check for nonstandard tenpai (for seven pairs and for thirteen orphans)

    // can return multiple values if there are multiple valid groupings

    println!(
        "{} remaining tiles: {:?}, tile_groups: {:?}",
        tiles.len(),
        tiles,
        tile_groups
    );

    let num_complete_groups = number_complete_groups(tile_groups);
    let num_incomplete_groups = number_incomplete_groups(tile_groups);
    let num_pair_groups = number_pair_groups(tile_groups);
    let num_single_tile_groups = number_single_tile_groups(tile_groups);
    let num_wait_groups = number_wait_groups(tile_groups);

    if num_incomplete_groups > 2 {
        println!("not tenpai hand: more than two incomplete groups");
        return None;
    }
    if num_single_tile_groups > 1 {
        println!("not tenpai hand: more than one single tile group");
        return None;
    }
    if num_single_tile_groups == 1 && num_incomplete_groups > 1 {
        println!(
            "not tenpai hand: if there is a single-tile group, all other groups must be complete"
        );
        return None;
    }
    if num_wait_groups > 1 {
        println!("not tenpai hand: more than one two-tile, non-pair wait group");
        return None;
    }
    if num_wait_groups == 1 && (num_pair_groups > 1 || num_single_tile_groups > 0) {
        println!(
            "not tenpai hand: if there is a two-tile, non-pair wait group, there can only be one other incomplete group, and it must be a pair"
        );
        return None;
    }
    if num_incomplete_groups == 2 && num_pair_groups == 0 {
        println!("not tenpai hand: two incomplete groups, but neither is a pair");
        return None;
    }
    if num_pair_groups == 2 && (num_single_tile_groups > 0 || num_wait_groups > 0) {
        println!(
            "not tenpai hand: two pair groups, but there are other incomplete groups is a pair"
        );
        return None;
    }
    if num_pair_groups == 1 && (num_single_tile_groups > 0 || num_wait_groups > 1) {
        println!("not tenpai hand: one pair group, there can only be one other two-tile, non-pair wait group");
        return None;
    }

    let must_be_complete_group = num_single_tile_groups > 0;
    let must_be_complete_group_or_pair = num_wait_groups > 0;

    if tiles.is_empty() {
        // println!("partial hand so far:");
        // println!("pair tile: {:?}", tiles::get_pair_group(hand_groups));
        // println!("melds: {:?}", hand_groups);
        if num_incomplete_groups == 0 {
            println!("not tenpai hand: no incomplete groups");
            return None;
        } else if num_single_tile_groups >= 1 {
            if num_single_tile_groups == 1 {
                if num_complete_groups == 4
                    && num_pair_groups == 0
                    && num_wait_groups == 0
                    && num_incomplete_groups == 1
                {
                    println!("found tenpai hand: {:?}", tile_groups);
                    return Some(vec![tile_groups.to_vec()]);
                } else {
                    println!("not tenpai hand: one single-tile group must be with 4 complete groups (no other incomplete groups)");
                    return None;
                }
            } else {
                println!("not tenpai hand: more than one single-tile group");
                return None;
            }
        } else if num_wait_groups >= 1 {
            if num_wait_groups == 1 {
                if num_pair_groups == 1
                    && num_complete_groups == 3
                    && num_incomplete_groups == 2
                    && num_single_tile_groups == 0
                {
                    println!("found tenpai hand: {:?}", tile_groups);
                    return Some(vec![tile_groups.to_vec()]);
                } else {
                    println!(
                        "not tenpai hand: one two-tile wait group must be with 3 complete groups and one pair group"
                    );
                    return None;
                }
            } else {
                println!("not tenpai hand: more than one two-tile wait group");
                return None;
            }
        } else if num_pair_groups >= 1 {
            if num_pair_groups == 1 {
                if num_wait_groups == 1
                    && num_complete_groups == 3
                    && num_incomplete_groups == 2
                    && num_single_tile_groups == 0
                {
                    println!("found tenpai hand: {:?}", tile_groups);
                    return Some(vec![tile_groups.to_vec()]);
                } else {
                    println!(
                        "not tenpai hand: one pair group must be with 3 complete groups and one two-tile wait group"
                    );
                    return None;
                }
            } else if num_pair_groups == 2 {
                if num_wait_groups == 0
                    && num_complete_groups == 3
                    && num_incomplete_groups == 2
                    && num_single_tile_groups == 0
                {
                    println!("found tenpai hand: {:?}", tile_groups);
                    return Some(vec![tile_groups.to_vec()]);
                } else {
                    println!("not tenpai hand: two pair groups must be with 3 complete groups (no other incomplete groups)");
                    return None;
                }
            } else {
                println!("not tenpai hand: more than two pair groups");
                return None;
            }
        } else {
            panic!("there should be at least one incomplete group of some type");
        }
    }
    // having one tile left could be a tenpai group (can't fail just yet)

    // this works with partial hand states e.g. excluding tiles from open melds, and when working recursively
    let remaining_tiles = tiles.clone();

    // count red-five tiles along with normal five tiles
    // e.g. 4m 0m 6m is a sequence, just like 4m 5m 6m
    let tile_counts_by_suit = count_tiles_by_suit_rank(&remaining_tiles, true);

    // check honor tiles:
    // since honor tiles cannot form sequences, all copies of each honor tile must belong to a single tile group
    let honor_suit = tiles::TileSuit::Honor;
    if let Some(honor_counts) = tile_counts_by_suit.get(&honor_suit) {
        for (tile_rank, tile_count) in honor_counts {
            let considered_tile = tiles::Tile::from_suit_and_rank(honor_suit, *tile_rank, 0);
            let considered_tile_str = considered_tile.to_string();

            if tile_count == &0 {
                continue;
            }
            if tile_count == &1 {
                // isolated honor tile

                if must_be_complete_group || must_be_complete_group_or_pair {
                    println!("cannot use isolated honor tile");
                    return None;
                }

                // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                // no way for a single honor tile type to be used in more than one meld/group

                // TODO improve the logic here
                // remove the pair of tiles from the vec
                let mut remaining_tiles = tiles.clone();
                let mut removed_tiles = Vec::new();
                for _copies in 0..1 {
                    for (tile_index, tile) in remaining_tiles.iter().enumerate() {
                        if tile.suit() == honor_suit && tile.rank() == *tile_rank {
                            removed_tiles.push(tile.clone());
                            remaining_tiles.swap_remove(tile_index);
                            break;
                        }
                    }
                }
                // println!("found single tile {}, remaining tiles: {:?}", considered_tile_str, remaining_tiles);

                // create the new single tile group with the correct tiles
                let single_tile_group = tiles::TileGroup::SingleTile {
                    tile: *(removed_tiles
                        .get(0)
                        .expect("Should have removed at least one tile")),
                };
                assert!(single_tile_group.is_valid());

                let mut new_groups = tile_groups.clone();
                new_groups.push(single_tile_group);

                // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                return tenpai_grouping(&remaining_tiles, &new_groups);
            } else if tile_count == &2 {
                // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                // no way for a single honor tile type to be used in more than one meld/group

                if must_be_complete_group {
                    println!("cannot use pair of honor tiles");
                    return None;
                }

                // TODO improve the logic here
                // remove the pair of tiles from the vec
                let mut remaining_tiles = tiles.clone();
                let mut removed_tiles = Vec::new();
                for _copies in 0..2 {
                    for (tile_index, tile) in remaining_tiles.iter().enumerate() {
                        if tile.suit() == honor_suit && tile.rank() == *tile_rank {
                            removed_tiles.push(tile.clone());
                            remaining_tiles.swap_remove(tile_index);
                            break;
                        }
                    }
                }
                // println!("found pair of {}, remaining tiles: {:?}", considered_tile_str, remaining_tiles);

                // create the new pair group with the correct tiles
                let pair_group = tiles::TileGroup::Pair {
                    tiles: [
                        *(removed_tiles
                            .get(0)
                            .expect("Should have removed at least one tile")),
                        *(removed_tiles
                            .get(1)
                            .expect("Should have removed at least two tiles")),
                    ],
                };
                assert!(pair_group.is_valid());

                let mut new_groups = tile_groups.clone();
                new_groups.push(pair_group);

                // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                return tenpai_grouping(&remaining_tiles, &new_groups);
            } else if tile_count == &3 || tile_count == &4 {
                // a triplet or a quad

                // remove all copies of this tile, honor tiles can't be used in sequences, so there's
                // no way for a single honor tile type to be used in more than one meld/group

                // TODO improve the logic here
                // remove the tiles from the vec
                let mut remaining_tiles = tiles.clone();
                let mut removed_tiles = Vec::new();
                for _copies in 0..*tile_count {
                    for (tile_index, tile) in remaining_tiles.iter().enumerate() {
                        if tile.suit() == honor_suit && tile.rank() == *tile_rank {
                            removed_tiles.push(tile.clone());
                            remaining_tiles.swap_remove(tile_index);
                            break;
                        }
                    }
                }
                // println!("found set of {}, remaining tiles: {:?}", considered_tile_str, remaining_tiles);

                // create the new group with the correct tiles
                if removed_tiles.len() == 3 {
                    let triplet_group = tiles::TileGroup::Triplet {
                        open: false,
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                            *(removed_tiles
                                .get(2)
                                .expect("Should have removed at least three tiles")),
                        ],
                    };
                    assert!(triplet_group.is_valid());

                    let mut new_groups = tile_groups.clone();
                    new_groups.push(triplet_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return tenpai_grouping(&remaining_tiles, &new_groups);
                } else if removed_tiles.len() == 4 {
                    let quad_group = tiles::TileGroup::Quad {
                        open: false,
                        added: false,
                        tiles: [
                            *(removed_tiles
                                .get(0)
                                .expect("Should have removed at least one tile")),
                            *(removed_tiles
                                .get(1)
                                .expect("Should have removed at least two tiles")),
                            *(removed_tiles
                                .get(2)
                                .expect("Should have removed at least three tiles")),
                            *(removed_tiles
                                .get(3)
                                .expect("Should have removed at least four tiles")),
                        ],
                    };
                    assert!(quad_group.is_valid());

                    let mut new_groups = tile_groups.clone();
                    new_groups.push(quad_group);

                    // if this doesn't work, there is no other option - so we can return here without trying other alternatives
                    return tenpai_grouping(&remaining_tiles, &new_groups);
                } else {
                    panic!("Should have only three or four tiles!");
                }
            } else {
                println!("impossible, cannot be more than 4 tiles!");
                return None;
            }
        }
    }

    // check number suits
    for tile_suit in [
        tiles::TileSuit::Man,
        tiles::TileSuit::Pin,
        tiles::TileSuit::Sou,
    ] {
        if let Some(tile_counts) = tile_counts_by_suit.get(&tile_suit) {
            // TODO why consider all of the ranks one by one? why not just consider only tile ranks with count > 0, sorted in ascending order
            for rank in 1..=9 {
                let tile_rank = tiles::TileRank::Number(
                    tiles::NumberTileRank::try_from(
                        char::from_digit(rank, 10).expect("Valid rank integer for char"),
                    )
                    .expect("valid tile rank"),
                );
                let new_tile_str = format!("{}{}", char::from(tile_rank), char::from(tile_suit));

                let tile_count = tile_counts.get(&tile_rank).unwrap_or(&0);
                let tile_count = *tile_count;

                if tile_count == 0 {
                    continue;
                }
                println!("considering tile {}", new_tile_str);
                let mut tenpai_hands: Vec<Vec<tiles::TileGroup>> = Vec::new();

                if tile_count >= 4 {
                    // four copies of number tile can be used for quad
                    println!("checking for quad of {new_tile_str}");

                    // build remaining tiles by removing four copies of the tile
                    let remaining_tiles = tiles.clone();
                    let (remaining_tiles, removed_first_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_second_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_third_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_fourth_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);

                    // new group
                    let new_quad_group = tiles::TileGroup::Quad {
                        open: false,
                        added: false,
                        tiles: [
                            removed_first_tile.expect("Should have removed at least one tile"),
                            removed_second_tile.expect("Should have removed at least two tiles"),
                            removed_third_tile.expect("Should have removed at least three tiles"),
                            removed_fourth_tile.expect("Should have removed at least four tiles"),
                        ],
                    };

                    // recursive call
                    println!("recursive call: using quad of {}", new_tile_str);

                    let mut new_groups = tile_groups.clone();
                    new_groups.push(new_quad_group);

                    if let Some(new_tenpai_hands) = tenpai_grouping(&remaining_tiles, &new_groups) {
                        // check if the new tenpai hands contain any duplicates
                        // TODO refactor to remove duplicated code (use fn that takes in mut reference to update tenpai_hands?)
                        // TODO refactor to improve performance?
                        let tenpai_hand_strings = get_tile_groups_strings(&tenpai_hands);
                        for new_tenpai_hand_grouping in new_tenpai_hands.iter() {
                            let new_tile_groups_string =
                                get_tile_groups_string(&new_tenpai_hand_grouping);
                            if !tenpai_hand_strings.contains(&new_tile_groups_string) {
                                tenpai_hands.push(new_tenpai_hand_grouping.clone());
                                println!(
                                    "found new tenpai grouping! {}, now there are {} tenpai_hands",
                                    new_tile_groups_string,
                                    tenpai_hands.len()
                                );
                            } else {
                                println!(
                                    "found duplicated tenpai grouping! {}",
                                    new_tile_groups_string
                                );
                            }
                        }
                    }
                }

                if tile_count >= 3 {
                    // three copies of number tile can be used for triplet
                    println!("checking for triplet of {new_tile_str}");

                    // build remaining tiles by removing three copies of the tile
                    let remaining_tiles = tiles.clone();
                    let (remaining_tiles, removed_first_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_second_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                    let (remaining_tiles, removed_third_tile) =
                        remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);

                    // new group
                    let new_triplet_group = tiles::TileGroup::Triplet {
                        open: false,
                        tiles: [
                            removed_first_tile.expect("Should have removed at least one tile"),
                            removed_second_tile.expect("Should have removed at least two tiles"),
                            removed_third_tile.expect("Should have removed at least three tiles"),
                        ],
                    };

                    // recursive call
                    println!("recursive call: using triplet of {}", new_tile_str);

                    let mut new_groups = tile_groups.clone();
                    new_groups.push(new_triplet_group);

                    if let Some(new_tenpai_hands) = tenpai_grouping(&remaining_tiles, &new_groups) {
                        // check if the new tenpai hands contain any duplicates
                        // TODO refactor to remove duplicated code (use fn that takes in mut reference to update tenpai_hands?)
                        // TODO refactor to improve performance?
                        let tenpai_hand_strings = get_tile_groups_strings(&tenpai_hands);
                        for new_tenpai_hand_grouping in new_tenpai_hands.iter() {
                            let new_tile_groups_string =
                                get_tile_groups_string(&new_tenpai_hand_grouping);
                            if !tenpai_hand_strings.contains(&new_tile_groups_string) {
                                tenpai_hands.push(new_tenpai_hand_grouping.clone());
                                println!(
                                    "found new tenpai grouping! {}, now there are {} tenpai_hands",
                                    new_tile_groups_string,
                                    tenpai_hands.len()
                                );
                            } else {
                                println!(
                                    "found duplicated tenpai grouping! {}",
                                    new_tile_groups_string
                                );
                            }
                        }
                    }
                }

                if tile_count >= 2 {
                    // two copies of number tile can be used for pair

                    if must_be_complete_group {
                        println!("cannot use pair of {} tiles", new_tile_str);
                    } else {
                        // build remaining tiles by removing two copies of the tile
                        let remaining_tiles = tiles.clone();
                        let (remaining_tiles, removed_first_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                        let (remaining_tiles, removed_second_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);

                        // new group
                        let new_pair_group = tiles::TileGroup::Pair {
                            tiles: [
                                removed_first_tile.expect("Should have removed at least one tile"),
                                removed_second_tile
                                    .expect("Should have removed at least two tiles"),
                            ],
                        };
                        // println!("found pair of {}, remaining tiles: {:?}", new_tile_str, remaining_tiles);

                        // recursive call
                        println!("recursive call: using pair of {}", new_tile_str);

                        let mut new_groups = tile_groups.clone();
                        new_groups.push(new_pair_group);

                        if let Some(new_tenpai_hands) =
                            tenpai_grouping(&remaining_tiles, &new_groups)
                        {
                            // check if the new tenpai hands contain any duplicates
                            // TODO refactor to remove duplicated code (use fn that takes in mut reference to update tenpai_hands?)
                            // TODO refactor to improve performance?
                            let tenpai_hand_strings = get_tile_groups_strings(&tenpai_hands);
                            for new_tenpai_hand_grouping in new_tenpai_hands.iter() {
                                let new_tile_groups_string =
                                    get_tile_groups_string(&new_tenpai_hand_grouping);
                                if !tenpai_hand_strings.contains(&new_tile_groups_string) {
                                    tenpai_hands.push(new_tenpai_hand_grouping.clone());
                                    println!(
                                        "found new tenpai grouping! {}, now there are {} tenpai_hands",
                                        new_tile_groups_string,
                                        tenpai_hands.len()
                                    );
                                } else {
                                    println!(
                                        "found duplicated tenpai grouping! {}",
                                        new_tile_groups_string
                                    );
                                }
                            }
                        }
                    }
                }

                if tile_count >= 1 {
                    // single number tile can be used for single tile, a wait pattern, or for a sequence

                    // always need to check for single tile

                    if must_be_complete_group || must_be_complete_group_or_pair {
                        println!("cannot use {} as single tile", new_tile_str);
                    } else {
                        let remaining_tiles = tiles.clone();
                        let (remaining_tiles, removed_first_tile) =
                            remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                        let new_single_tile_group = tiles::TileGroup::SingleTile {
                            tile: removed_first_tile
                                .expect("Should have removed at least one tile"),
                        };
                        let mut new_groups = tile_groups.clone();
                        new_groups.push(new_single_tile_group);
                        println!("recursive call: using single tile {}", new_tile_str);
                        if let Some(new_tenpai_hands) =
                            tenpai_grouping(&remaining_tiles, &new_groups)
                        {
                            // check if the new tenpai hands contain any duplicates
                            // TODO refactor to remove duplicated code (use fn that takes in mut reference to update tenpai_hands?)
                            // TODO refactor to improve performance?
                            let tenpai_hand_strings = get_tile_groups_strings(&tenpai_hands);
                            for new_tenpai_hand_grouping in new_tenpai_hands.iter() {
                                let new_tile_groups_string =
                                    get_tile_groups_string(&new_tenpai_hand_grouping);
                                if !tenpai_hand_strings.contains(&new_tile_groups_string) {
                                    tenpai_hands.push(new_tenpai_hand_grouping.clone());
                                    println!(
                                        "found new tenpai grouping! {}, now there are {} tenpai_hands",
                                        new_tile_groups_string,
                                        tenpai_hands.len()
                                    );
                                } else {
                                    println!(
                                        "found duplicated tenpai grouping! {}",
                                        new_tile_groups_string
                                    );
                                }
                            }
                        }
                    }

                    // check for presence of higher rank tiles
                    // TODO refactor?
                    let second_rank = rank + 1;
                    let third_rank = rank + 2;

                    if second_rank <= 9 {
                        assert!(second_rank >= 1 && second_rank <= 9);
                        let second_tile_rank = tiles::NumberTileRank::try_from(
                            char::from_digit(second_rank, 10).expect("Valid rank integer for char"),
                        );

                        // need to check for open/edge wait as well
                        if must_be_complete_group || must_be_complete_group_or_pair {
                            println!("cannot use {} as open/edge wait", new_tile_str);
                        } else {
                            if second_tile_rank.is_ok()
                                && tile_counts
                                    .get(
                                        &(tiles::TileRank::Number(
                                            second_tile_rank.expect("Result should not be Err!"),
                                        )),
                                    )
                                    .unwrap_or(&0)
                                    > &0
                            {
                                println!(
                                    "checking for open/edge wait starting at {}",
                                    new_tile_str
                                );
                                let second_tile_rank = tiles::TileRank::Number(
                                    second_tile_rank.expect("Result should not be Err!"),
                                );
                                // build remaining tiles
                                let remaining_tiles = tiles.clone();
                                let (remaining_tiles, removed_first_tile) =
                                    remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                                let (remaining_tiles, removed_second_tile) = remove_first_copy(
                                    remaining_tiles,
                                    second_tile_rank,
                                    tile_suit,
                                    true,
                                );

                                // new group
                                let new_group_tiles = [
                                    removed_first_tile
                                        .expect("Should have removed at least one tile"),
                                    removed_second_tile
                                        .expect("Should have removed at least two tiles"),
                                ];
                                let new_wait_group = if rank == 1 || second_rank == 9 {
                                    tiles::TileGroup::EdgeWait {
                                        tiles: new_group_tiles,
                                    }
                                } else {
                                    tiles::TileGroup::OpenWait {
                                        tiles: new_group_tiles,
                                    }
                                };

                                // recursive call
                                let mut new_groups = tile_groups.clone();
                                new_groups.push(new_wait_group);
                                println!(
                                    "recursive call: using open/edge wait starting at {}",
                                    new_tile_str
                                );

                                if let Some(new_tenpai_hands) =
                                    tenpai_grouping(&remaining_tiles, &new_groups)
                                {
                                    // check if the new tenpai hands contain any duplicates
                                    // TODO refactor to remove duplicated code (use fn that takes in mut reference to update tenpai_hands?)
                                    // TODO refactor to improve performance?
                                    let tenpai_hand_strings =
                                        get_tile_groups_strings(&tenpai_hands);
                                    for new_tenpai_hand_grouping in new_tenpai_hands.iter() {
                                        let new_tile_groups_string =
                                            get_tile_groups_string(&new_tenpai_hand_grouping);
                                        if !tenpai_hand_strings.contains(&new_tile_groups_string) {
                                            tenpai_hands.push(new_tenpai_hand_grouping.clone());
                                            println!(
                                                "found new tenpai grouping! {}, now there are {} tenpai_hands",
                                                new_tile_groups_string,
                                                tenpai_hands.len()
                                            );
                                        } else {
                                            println!(
                                                "found duplicated tenpai grouping! {}",
                                                new_tile_groups_string
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if third_rank <= 9 {
                        // need to check for closed wait and sequence as well
                        assert!(second_rank >= 1 && second_rank <= 9);
                        assert!(third_rank >= 1 && third_rank <= 9);
                        let second_tile_rank = tiles::NumberTileRank::try_from(
                            char::from_digit(second_rank, 10).expect("Valid rank integer for char"),
                        );
                        let third_tile_rank = tiles::NumberTileRank::try_from(
                            char::from_digit(third_rank, 10).expect("Valid rank integer for char"),
                        );

                        if must_be_complete_group || must_be_complete_group_or_pair {
                            println!("cannot use {} as closed wait", new_tile_str);
                        } else {
                            // check for closed wait
                            if third_tile_rank.is_ok()
                                && tile_counts
                                    .get(
                                        &(tiles::TileRank::Number(
                                            third_tile_rank.expect("Result should not be Err!"),
                                        )),
                                    )
                                    .unwrap_or(&0)
                                    > &0
                            {
                                println!("checking for closed wait starting at {}", new_tile_str);
                                let third_tile_rank = tiles::TileRank::Number(
                                    third_tile_rank.expect("Result should not be Err!"),
                                );

                                // build remaining tiles by removing one copy of each of the three tiles in the sequence
                                let remaining_tiles = tiles.clone();
                                let (remaining_tiles, removed_first_tile) =
                                    remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                                let (remaining_tiles, removed_third_tile) = remove_first_copy(
                                    remaining_tiles,
                                    third_tile_rank,
                                    tile_suit,
                                    true,
                                );

                                // new group
                                let new_wait_group = tiles::TileGroup::ClosedWait {
                                    tiles: [
                                        removed_first_tile
                                            .expect("Should have removed at least one tile"),
                                        removed_third_tile
                                            .expect("Should have removed at least three tiles"),
                                    ],
                                };

                                // recursive call
                                let mut new_groups = tile_groups.clone();
                                new_groups.push(new_wait_group);
                                println!(
                                    "recursive call: using closed wait starting at {}",
                                    new_tile_str
                                );

                                if let Some(new_tenpai_hands) =
                                    tenpai_grouping(&remaining_tiles, &new_groups)
                                {
                                    // check if the new tenpai hands contain any duplicates
                                    // TODO refactor to remove duplicated code (use fn that takes in mut reference to update tenpai_hands?)
                                    // TODO refactor to improve performance?
                                    let tenpai_hand_strings =
                                        get_tile_groups_strings(&tenpai_hands);
                                    for new_tenpai_hand_grouping in new_tenpai_hands.iter() {
                                        let new_tile_groups_string =
                                            get_tile_groups_string(&new_tenpai_hand_grouping);
                                        if !tenpai_hand_strings.contains(&new_tile_groups_string) {
                                            tenpai_hands.push(new_tenpai_hand_grouping.clone());
                                            println!(
                                                "found new tenpai grouping! {}, now there are {} tenpai_hands",
                                                new_tile_groups_string,
                                                tenpai_hands.len()
                                            );
                                        } else {
                                            println!(
                                                "found duplicated tenpai grouping! {}",
                                                new_tile_groups_string
                                            );
                                        }
                                    }
                                }
                            }
                        }

                        // check for sequence
                        if second_tile_rank.is_ok()
                            && third_tile_rank.is_ok()
                            && tile_counts
                                .get(
                                    &(tiles::TileRank::Number(
                                        second_tile_rank.expect("Result should not be Err!"),
                                    )),
                                )
                                .unwrap_or(&0)
                                > &0
                            && tile_counts
                                .get(
                                    &(tiles::TileRank::Number(
                                        third_tile_rank.expect("Result should not be Err!"),
                                    )),
                                )
                                .unwrap_or(&0)
                                > &0
                        {
                            println!("checking for sequence starting at {}", new_tile_str);
                            let second_tile_rank = tiles::TileRank::Number(
                                second_tile_rank.expect("Result should not be Err!"),
                            );
                            let third_tile_rank = tiles::TileRank::Number(
                                third_tile_rank.expect("Result should not be Err!"),
                            );

                            // build remaining tiles by removing one copy of each of the three tiles in the sequence
                            let remaining_tiles = tiles.clone();
                            let (remaining_tiles, removed_first_tile) =
                                remove_first_copy(remaining_tiles, tile_rank, tile_suit, true);
                            let (remaining_tiles, removed_second_tile) = remove_first_copy(
                                remaining_tiles,
                                second_tile_rank,
                                tile_suit,
                                true,
                            );
                            let (remaining_tiles, removed_third_tile) = remove_first_copy(
                                remaining_tiles,
                                third_tile_rank,
                                tile_suit,
                                true,
                            );

                            // new group
                            let new_sequence_group = tiles::TileGroup::Sequence {
                                open: false,
                                tiles: [
                                    removed_first_tile
                                        .expect("Should have removed at least one tile"),
                                    removed_second_tile
                                        .expect("Should have removed at least two tiles"),
                                    removed_third_tile
                                        .expect("Should have removed at least three tiles"),
                                ],
                            };

                            // if any existing winning hands use this sequence, you may still need to make this recursive call
                            // e.g. for a hand with two identical sequences (e.g. 334455m, a valid winning hand will include multiple
                            // identical melds)

                            // recursive call
                            let mut new_groups = tile_groups.clone();
                            new_groups.push(new_sequence_group);
                            println!(
                                "recursive call: using sequence starting at {}",
                                new_tile_str
                            );

                            if let Some(new_tenpai_hands) =
                                tenpai_grouping(&remaining_tiles, &new_groups)
                            {
                                // check if the new tenpai hands contain any duplicates
                                // TODO refactor to remove duplicated code (use fn that takes in mut reference to update tenpai_hands?)
                                // TODO refactor to improve performance?
                                let tenpai_hand_strings = get_tile_groups_strings(&tenpai_hands);
                                for new_tenpai_hand_grouping in new_tenpai_hands.iter() {
                                    let new_tile_groups_string =
                                        get_tile_groups_string(&new_tenpai_hand_grouping);
                                    if !tenpai_hand_strings.contains(&new_tile_groups_string) {
                                        tenpai_hands.push(new_tenpai_hand_grouping.clone());
                                        println!(
                                            "found new tenpai grouping! {}, now there are {} tenpai_hands",
                                            new_tile_groups_string,
                                            tenpai_hands.len()
                                        );
                                    } else {
                                        println!(
                                            "found duplicated tenpai grouping! {}",
                                            new_tile_groups_string
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
                // we have to use this tile in the tenpai hand somehow - if there's no tenpai hands at this point,
                // then there are no tenpai hands at all
                println!(
                    "there are {} tenpai_hands for tile {}",
                    tenpai_hands.len(),
                    new_tile_str
                );
                return if tenpai_hands.is_empty() {
                    println!("invalid grouping: could not use tile {}", new_tile_str);
                    None
                } else {
                    Some(tenpai_hands)
                };
            }
        }
    }

    // TODO can this ever get here?
    return None;
}

pub fn tenpai_wait_tiles_from_grouping(tile_groups: &Vec<tiles::TileGroup>) -> Vec<tiles::Tile> {
    // returns the tiles that this grouping can win on
    // (if this is a valid grouping for "standard" tenpai i.e. not seven pairs or thirteen orphans)
    let mut wait_tiles: Vec<tiles::Tile> = Vec::new();

    let num_pair_groups = number_pair_groups(tile_groups);

    for group in tile_groups {
        if group.is_complete() {
            continue;
        }
        match group {
            tiles::TileGroup::Pair { tiles } => {
                // only can wait on this tile if the wait is shanpon (if there is only one pair, we cannot add this tile, the pair must remain)
                if num_pair_groups == 2 {
                    wait_tiles.push(tiles[0].clone());
                }
            }
            tiles::TileGroup::SingleTile { tile } => {
                wait_tiles.push(tile.clone());
            }
            tiles::TileGroup::ClosedWait { tiles } => {
                // get the middle tile
                let rank0 = tiles[0]
                    .rank_numeric_value()
                    .expect("Closed wait tile should be a numbered suit");
                let rank1 = tiles[1]
                    .rank_numeric_value()
                    .expect("Closed wait tile should be a numbered suit");
                assert!(rank0 + 2 == rank1 || rank1 + 2 == rank0);
                let new_rank = if rank0 < rank1 { rank0 + 1 } else { rank1 + 1 };
                let new_rank_char = char::from_digit(new_rank.into(), 10)
                    .expect("Expect to be able to convert rank to char");
                let new_number_rank = tiles::NumberTileRank::try_from(new_rank_char)
                    .expect("Expect to be able to convert tile rank to number");
                let new_tile = tiles::Tile::from_suit_and_rank(
                    tiles[0].suit(),
                    tiles::TileRank::Number(new_number_rank),
                    0,
                );
                wait_tiles.push(new_tile);
            }
            tiles::TileGroup::EdgeWait { tiles } => {
                // get the edge tile
                let rank0 = tiles[0]
                    .rank_numeric_value()
                    .expect("Edge wait tile should be a numbered suit");
                let rank1 = tiles[1]
                    .rank_numeric_value()
                    .expect("Edge wait tile should be a numbered suit");
                assert!(
                    (rank0 + 1 == rank1 || rank1 + 1 == rank0)
                        && (rank0 == 1 || rank0 == 9 || rank1 == 1 || rank1 == 9)
                );
                let new_rank: u32 = if rank0 < rank1 {
                    if rank0 == 1 {
                        3
                    } else {
                        7
                    }
                } else {
                    if rank1 == 1 {
                        3
                    } else {
                        7
                    }
                };
                let new_rank_char = char::from_digit(new_rank.into(), 10)
                    .expect("Expect to be able to convert rank to char");
                let new_number_rank = tiles::NumberTileRank::try_from(new_rank_char)
                    .expect("Expect to be able to convert tile rank to number");
                let new_tile = tiles::Tile::from_suit_and_rank(
                    tiles[0].suit(),
                    tiles::TileRank::Number(new_number_rank),
                    0,
                );
                wait_tiles.push(new_tile);
            }
            tiles::TileGroup::OpenWait { tiles } => {
                // get the tiles around the open wait
                let rank0 = tiles[0]
                    .rank_numeric_value()
                    .expect("Open wait tile should be a numbered suit");
                let rank1 = tiles[1]
                    .rank_numeric_value()
                    .expect("Open wait tile should be a numbered suit");
                assert!(
                    (rank0 + 1 == rank1 || rank1 + 1 == rank0)
                        && (rank0 != 1 && rank0 != 9 && rank1 != 1 && rank1 != 9)
                );
                let lower_tile_rank: u32 = if rank0 < rank1 {
                    rank0.into()
                } else {
                    rank1.into()
                };
                let new_rank_low = lower_tile_rank - 1;
                let new_rank_high = lower_tile_rank + 2;

                let new_rank_low_char = char::from_digit(new_rank_low, 10)
                    .expect("Expect to be able to convert rank to char");
                let new_number_rank_low = tiles::NumberTileRank::try_from(new_rank_low_char)
                    .expect("Expect to be able to convert tile rank to number");
                let new_tile_low = tiles::Tile::from_suit_and_rank(
                    tiles[0].suit(),
                    tiles::TileRank::Number(new_number_rank_low),
                    0,
                );
                wait_tiles.push(new_tile_low);

                let new_rank_high_char = char::from_digit(new_rank_high, 10)
                    .expect("Expect to be able to convert rank to char");
                let new_number_rank_high = tiles::NumberTileRank::try_from(new_rank_high_char)
                    .expect("Expect to be able to convert tile rank to number");
                let new_tile_high = tiles::Tile::from_suit_and_rank(
                    tiles[0].suit(),
                    tiles::TileRank::Number(new_number_rank_high),
                    0,
                );
                wait_tiles.push(new_tile_high);
            }
            _ => {
                panic!("invalid, expecting an incomplete group");
            }
        };
    }
    wait_tiles
}

pub fn get_all_tenpai_wait_tiles(tiles: &Vec<tiles::Tile>) -> Vec<tiles::Tile> {
    // returns the tiles that this grouping can win on (if not in tenpai, returns empty Vec)
    // (if this is a valid grouping for "standard" tenpai i.e. not seven pairs or thirteen orphans)

    let empty_groups: Vec<tiles::TileGroup> = Vec::new();
    let potential_groupings = tenpai_grouping(tiles, &empty_groups);
    match potential_groupings {
        None => {
            let wait_tiles: Vec<tiles::Tile> = Vec::new();
            wait_tiles
        }
        Some(tile_groupings) => {
            let mut wait_tiles: Vec<tiles::Tile> = Vec::new();
            for tile_grouping in tile_groupings {
                let wait_tiles_from_grouping = tenpai_wait_tiles_from_grouping(&tile_grouping);
                for potential_tile in wait_tiles_from_grouping {
                    // edge case: if this tile is already used four times in the hand, we can't wait on a fifth copy
                    let num_tiles_already_in_hand = tiles
                        .iter()
                        .filter(|tile| tile.serial == potential_tile.serial)
                        .count();
                    if num_tiles_already_in_hand == 4 {
                        continue;
                    }

                    // add if it's not already in the `wait_tiles` Vec
                    let count_existing = wait_tiles
                        .iter()
                        .filter(|tile| tile.to_human_string() == potential_tile.to_human_string())
                        .count();
                    if count_existing == 0 {
                        wait_tiles.push(potential_tile);
                    }
                }
            }
            wait_tiles
        }
    }
}

#[cfg(test)]
mod tests {
    // importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_count_tiles_by_suit_rank() {
        let tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("6z"), // green dragon
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("3z"), // west wind
            tiles::Tile::from_string("3z"),
            tiles::Tile::from_string("3z"),
        ]);

        let counts = count_tiles_by_suit_rank(&tiles, true);
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::One)),
            Some(&3)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Two)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Three)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Four)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Eight)),
            Some(&2)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Honor)
                .unwrap()
                .get(&tiles::TileRank::Honor(tiles::HonorTileRank::Green)),
            Some(&2)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Honor)
                .unwrap()
                .get(&tiles::TileRank::Honor(tiles::HonorTileRank::West)),
            Some(&3)
        );
    }

    #[test]
    fn test_count_tiles_by_suit_rank_red_fives() {
        let tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("0m"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("0p"),
        ]);

        let counts = count_tiles_by_suit_rank(&tiles, true);
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::One)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&3)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            None
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Sou)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&3)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Sou)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            None
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Pin)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&1)
        );
        assert_eq!(
            counts
                .get(&tiles::TileSuit::Pin)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            None
        );

        let counts_separate_red_fives = count_tiles_by_suit_rank(&tiles, false);
        assert_eq!(
            counts_separate_red_fives
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::Five)),
            Some(&2)
        );
        assert_eq!(
            counts_separate_red_fives
                .get(&tiles::TileSuit::Man)
                .unwrap()
                .get(&tiles::TileRank::Number(tiles::NumberTileRank::RedFive)),
            Some(&1)
        );
    }

    // winning hands taken from my Mahjong Soul logs
    // game: 4-player East round, Silver room, 2023-06-03 09:26
    #[test]
    fn test_tile_grouping_1() {
        // round: East 1 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 3 han, 40 fu = 5200 pts (riichi, ippatsu, dora x1 (3m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("3m"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_2() {
        // round: East 2 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 3 han, 40 fu = 5200 pts (riichi, red five x1, ura dora x1 (4m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("0m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("7m"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_3() {
        // round: East 3 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 4 han, 40 fu = mangan (8000 pts) (riichi, pure double sequence, red five x1, ura dora x1 (2m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("0m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6z"), // green dragon
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("4p"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_4() {
        // round: East 4 (0 repeat), winning hand by West (open hand, ron)
        // scoring: 4 han, 30 fu = 7700 pts (white dragon, dora x3 (7m, 8p))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("5z"), // white dragon
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("2m"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = vec![
            tiles::TileGroup::Sequence {
                open: true,
                tiles: [
                    tiles::Tile::from_string("4s"),
                    tiles::Tile::from_string("5s"),
                    tiles::Tile::from_string("3s"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                ],
            },
        ];
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        let winning_tile_groups = winning_tile_groups.expect("Expect one winning grouping");
        assert!(winning_tile_groups.len() == 1);
    }

    // winning hands taken from my Mahjong Soul logs
    // game: 4-player East round, Silver room, 2023-06-03 01:15
    #[test]
    fn test_tile_grouping_5() {
        // round: East 1 (0 repeat), winning hand by North (riichi, ron)
        // scoring: 5 han, 40 fu = mangan (8000 pts) (riichi, mixed triple sequence, red five x1)
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("0p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("1s"),
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("4p"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_6() {
        // round: East 2 (1 repeat), winning hand by East (riichi, ron)
        // scoring: 2 han, 40 fu = 2600 pts (riichi, ura dora x1 (4m))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("9s"),
            tiles::Tile::from_string("7s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_7() {
        // round: East 3 (1 repeat), winning hand by North (riichi, ron)
        // scoring: 3 han, 30 fu = 3900 pts (riichi, pinfu, ura dora x1 (3p))
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("1m"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_8() {
        // round: East 4 (0 repeat), winning hand by North (open hand, ron)
        // scoring: 2 han, 30 fu = 2000 pts (all simples, red five x1)
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("0s"),
            tiles::Tile::from_string("4s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = vec![
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("6p"),
                    tiles::Tile::from_string("6p"),
                    tiles::Tile::from_string("6p"),
                ],
            },
            tiles::TileGroup::Sequence {
                open: true,
                tiles: [
                    tiles::Tile::from_string("4m"),
                    tiles::Tile::from_string("5m"),
                    tiles::Tile::from_string("3m"),
                ],
            },
        ];
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_9() {
        // round: East 4 (0 repeat), winning hand by East (open hand, ron)
        // scoring: 3 han, 30 fu = 5800 pts (all simples, all triplets)
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = vec![
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("7m"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("8m"),
                    tiles::Tile::from_string("8m"),
                    tiles::Tile::from_string("8m"),
                ],
            },
        ];
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        assert!(
            winning_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );
    }

    #[test]
    fn test_tile_grouping_multiple_groupings() {
        // example of hand with multiple valid winning groupings (scoring needs to consider which grouping produces the
        // highest score, prioritizing higher han value, then higher fu value)
        // example hand from: https://riichi.wiki/Fu#Maximal_Score
        let winning_tiles = Vec::from([
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("9m"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("9s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let winning_tile_groups = tile_grouping(&winning_tiles, &tile_groups);
        assert!(winning_tile_groups.is_some());
        let winning_tile_groups = winning_tile_groups.expect("Expect some winning groupings");
        assert!(winning_tile_groups.len() == 2);

        // the pair is either the 6p or the 9p
        let first_winning_grouping = winning_tile_groups
            .get(0)
            .expect("Expect two winning groupings");
        let second_winning_grouping = winning_tile_groups
            .get(1)
            .expect("Expect two winning groupings");
        let grouping_pair_tiles = [
            tiles::get_pair_group(&first_winning_grouping)
                .expect("winning grouping must have a pair")
                .to_string(),
            tiles::get_pair_group(&second_winning_grouping)
                .expect("winning grouping must have a pair")
                .to_string(),
        ];
        assert!(
            grouping_pair_tiles.contains(&String::from("6p"))
                && grouping_pair_tiles.contains(&String::from("9p"))
        );
    }

    #[test]
    fn test_tenpai_grouping_two_pairs() {
        // from riichi wiki: https://riichi.wiki/Tenpai
        let tenpai_tiles = Vec::new();

        let tile_groups: Vec<tiles::TileGroup> = Vec::from([
            tiles::TileGroup::Sequence {
                open: false,
                tiles: [
                    tiles::Tile::from_string("1p"),
                    tiles::Tile::from_string("2p"),
                    tiles::Tile::from_string("3p"),
                ],
            },
            tiles::TileGroup::Sequence {
                open: false,
                tiles: [
                    tiles::Tile::from_string("4p"),
                    tiles::Tile::from_string("5p"),
                    tiles::Tile::from_string("6p"),
                ],
            },
            tiles::TileGroup::Sequence {
                open: false,
                tiles: [
                    tiles::Tile::from_string("7p"),
                    tiles::Tile::from_string("8p"),
                    tiles::Tile::from_string("9p"),
                ],
            },
            tiles::TileGroup::Pair {
                tiles: [
                    tiles::Tile::from_string("3m"),
                    tiles::Tile::from_string("3m"),
                ],
            },
            tiles::TileGroup::Pair {
                tiles: [
                    tiles::Tile::from_string("5s"),
                    tiles::Tile::from_string("5s"),
                ],
            },
        ]);
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        assert!(
            tenpai_tile_groups
                .expect("Expect one tenpai grouping")
                .len()
                == 1
        );

        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("9p"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        assert!(
            tenpai_tile_groups
                .expect("Expect one tenpai grouping")
                .len()
                == 1
        );

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=123456789p33m55s
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 2);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        assert!(wait_tiles_human_strs.contains(&String::from("3m")));
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
    }

    #[test]
    fn test_tenpai_grouping_pair_and_wait() {
        // from riichi wiki: https://riichi.wiki/Tenpai
        let tenpai_tiles = Vec::new();

        let tile_groups: Vec<tiles::TileGroup> = Vec::from([
            tiles::TileGroup::Triplet {
                open: false,
                tiles: [
                    tiles::Tile::from_string("1m"),
                    tiles::Tile::from_string("1m"),
                    tiles::Tile::from_string("1m"),
                ],
            },
            tiles::TileGroup::Sequence {
                open: false,
                tiles: [
                    tiles::Tile::from_string("2s"),
                    tiles::Tile::from_string("3s"),
                    tiles::Tile::from_string("4s"),
                ],
            },
            tiles::TileGroup::OpenWait {
                tiles: [
                    tiles::Tile::from_string("5s"),
                    tiles::Tile::from_string("6s"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: false,
                tiles: [
                    tiles::Tile::from_string("8p"),
                    tiles::Tile::from_string("8p"),
                    tiles::Tile::from_string("8p"),
                ],
            },
            tiles::TileGroup::Pair {
                tiles: [
                    tiles::Tile::from_string("3z"),
                    tiles::Tile::from_string("3z"),
                ],
            },
        ]);
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        assert!(
            tenpai_tile_groups
                .expect("Expect one tenpai grouping")
                .len()
                == 1
        );

        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("3z"),
            tiles::Tile::from_string("3z"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        // two valid groupings as the 23456s can be broken into 234+56 or 23+456
        assert!(
            tenpai_tile_groups
                .expect("Expect two tenpai groupings")
                .len()
                == 2
        );

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=111m23456s888p33z
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 3);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        assert!(wait_tiles_human_strs.contains(&String::from("1s")));
        assert!(wait_tiles_human_strs.contains(&String::from("4s")));
        assert!(wait_tiles_human_strs.contains(&String::from("7s")));
    }

    #[test]
    fn test_tenpai_grouping_single_wait() {
        // from riichi wiki: https://riichi.wiki/Tenpai
        let tenpai_tiles = Vec::new();

        let tile_groups: Vec<tiles::TileGroup> = Vec::from([
            tiles::TileGroup::Sequence {
                open: true,
                tiles: [
                    tiles::Tile::from_string("6m"),
                    tiles::Tile::from_string("7m"),
                    tiles::Tile::from_string("8m"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("1p"),
                    tiles::Tile::from_string("1p"),
                    tiles::Tile::from_string("1p"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: true,
                tiles: [
                    tiles::Tile::from_string("7s"),
                    tiles::Tile::from_string("7s"),
                    tiles::Tile::from_string("7s"),
                ],
            },
            tiles::TileGroup::Sequence {
                open: true,
                tiles: [
                    tiles::Tile::from_string("3s"),
                    tiles::Tile::from_string("4s"),
                    tiles::Tile::from_string("5s"),
                ],
            },
            tiles::TileGroup::SingleTile {
                tile: tiles::Tile::from_string("1z"),
            },
        ]);
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        assert!(
            tenpai_tile_groups
                .expect("Expect one tenpai grouping")
                .len()
                == 1
        );

        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("8m"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("1z"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        assert!(
            tenpai_tile_groups
                .expect("Expect one tenpai grouping")
                .len()
                == 1
        );

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=678m111p777s345s1z
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 1);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        println!("tenpai wait tiles = {:?}", wait_tiles);
        assert!(wait_tiles_human_strs.contains(&String::from("1z")));
    }

    #[test]
    fn test_tenpai_grouping_aryanmen() {
        // a combination of the ryanmen (i.e. open wait) and pair
        // https://riichi.wiki/Aryanmen

        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("7p"),
            tiles::Tile::from_string("8p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("2p"),
            tiles::Tile::from_string("3p"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("9s"),
            tiles::Tile::from_string("6m"),
            tiles::Tile::from_string("7m"),
            tiles::Tile::from_string("5m"),
            tiles::Tile::from_string("5m"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        // two tenpai groupings: the 5567m can be considered as 55-67 (open wait) or 5-567 (single tile wait)
        let tenpai_groupings = tenpai_tile_groups.expect("Expect two tenpai groupings");
        println!("{:?}", tenpai_groupings);
        assert!(tenpai_groupings.len() == 2);

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=678p123p789s6755m
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 2);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        assert!(wait_tiles_human_strs.contains(&String::from("5m")));
        assert!(wait_tiles_human_strs.contains(&String::from("8m")));
    }

    #[test]
    fn test_tenpai_grouping_four_copies() {
        let winning_tiles = Vec::from([
            // four copies of 1m = the correct grouping is 2 sequences and a pair (11+123+123)
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("3m"),
            // four copies of 4s = the correct grouping is triplet and open wait (444+45)
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&winning_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        assert!(
            tenpai_tile_groups
                .expect("Expect one winning grouping")
                .len()
                == 1
        );

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=11112233m44445s
        let wait_tiles = get_all_tenpai_wait_tiles(&winning_tiles);
        assert_eq!(wait_tiles.len(), 2);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        assert!(wait_tiles_human_strs.contains(&String::from("3s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
    }

    #[test]
    fn test_tenpai_grouping_complex_tenpai_chinitsu() {
        let winning_tiles = Vec::from([
            // 8 possible tenpai groupings:
            // 111-12-234-345-44 -> wait: 3m
            // 111-13-22-345-444 -> wait: 2m
            // 111-123-2-345-444 -> wait: 2m
            // 111-123-24-44-345 -> wait: 3m
            // 111-123-234-44-45 -> wait: 36m
            // 111-123-234-444-5 -> wait: 5m
            // 11-123-12-345-444 -> wait: 3m
            // 11-123-123-444-45 -> wait: 36m
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("2m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("3m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("4m"),
            tiles::Tile::from_string("5m"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&winning_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());
        assert!(
            tenpai_tile_groups
                .expect("Expect eight winning groupings")
                .len()
                == 8
        );

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=1111223344445m
        let wait_tiles = get_all_tenpai_wait_tiles(&winning_tiles);
        assert_eq!(wait_tiles.len(), 4);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        assert!(wait_tiles_human_strs.contains(&String::from("2m")));
        assert!(wait_tiles_human_strs.contains(&String::from("3m")));
        assert!(wait_tiles_human_strs.contains(&String::from("5m")));
        assert!(wait_tiles_human_strs.contains(&String::from("6m")));
    }

    #[test]
    fn test_not_tenpai_grouping_1() {
        // from riichi wiki: https://riichi.wiki/Shanten
        // not tenpai, too many incomplete groups
        let tenpai_tiles = Vec::new();

        let tile_groups: Vec<tiles::TileGroup> = Vec::from([
            tiles::TileGroup::Triplet {
                open: false,
                tiles: [
                    tiles::Tile::from_string("1m"),
                    tiles::Tile::from_string("1m"),
                    tiles::Tile::from_string("1m"),
                ],
            },
            tiles::TileGroup::Sequence {
                open: false,
                tiles: [
                    tiles::Tile::from_string("4p"),
                    tiles::Tile::from_string("5p"),
                    tiles::Tile::from_string("6p"),
                ],
            },
            tiles::TileGroup::ClosedWait {
                tiles: [
                    tiles::Tile::from_string("2s"),
                    tiles::Tile::from_string("4s"),
                ],
            },
            tiles::TileGroup::SingleTile {
                tile: tiles::Tile::from_string("6s"),
            },
            tiles::TileGroup::Pair {
                tiles: [
                    tiles::Tile::from_string("1z"),
                    tiles::Tile::from_string("1z"),
                ],
            },
            tiles::TileGroup::Pair {
                tiles: [
                    tiles::Tile::from_string("5z"),
                    tiles::Tile::from_string("5z"),
                ],
            },
        ]);
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_none());

        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("4p"),
            tiles::Tile::from_string("5p"),
            tiles::Tile::from_string("6p"),
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("1z"),
            tiles::Tile::from_string("1z"),
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("5z"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_none());

        // confirmed not tenpai: https://riichi.harphield.com/tools/hand-analyzer/?hand=111m456p246s1155z
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 0);
    }

    #[test]
    fn test_not_tenpai_grouping_2() {
        // from riichi wiki: https://riichi.wiki/Shanten
        // not tenpai, 3 complete groups + pair + single tile is not tenpai (it's not a complete hand)
        let tenpai_tiles = Vec::new();

        let tile_groups: Vec<tiles::TileGroup> = Vec::from([
            tiles::TileGroup::Triplet {
                open: false,
                tiles: [
                    tiles::Tile::from_string("1m"),
                    tiles::Tile::from_string("1m"),
                    tiles::Tile::from_string("1m"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: false,
                tiles: [
                    tiles::Tile::from_string("1p"),
                    tiles::Tile::from_string("1p"),
                    tiles::Tile::from_string("1p"),
                ],
            },
            tiles::TileGroup::Triplet {
                open: false,
                tiles: [
                    tiles::Tile::from_string("1s"),
                    tiles::Tile::from_string("1s"),
                    tiles::Tile::from_string("1s"),
                ],
            },
            tiles::TileGroup::SingleTile {
                tile: tiles::Tile::from_string("5s"),
            },
            tiles::TileGroup::Pair {
                tiles: [
                    tiles::Tile::from_string("1z"),
                    tiles::Tile::from_string("1z"),
                ],
            },
        ]);
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert_eq!(number_pair_groups(&tile_groups), 1);
        assert_eq!(number_single_tile_groups(&tile_groups), 1);
        assert!(tenpai_tile_groups.is_none());

        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1m"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1p"),
            tiles::Tile::from_string("1s"),
            tiles::Tile::from_string("1s"),
            tiles::Tile::from_string("1s"),
            tiles::Tile::from_string("1z"),
            tiles::Tile::from_string("1z"),
            tiles::Tile::from_string("5s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_none());

        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 0);
    }

    // TODO test: cannot have multiple pair groups or single tile groups that use the same tiles and be in tenpai

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q1() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 1:
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("1z"),
            tiles::Tile::from_string("1z"),
            tiles::Tile::from_string("1z"),
            tiles::Tile::from_string("7z"),
            tiles::Tile::from_string("7z"),
            tiles::Tile::from_string("7z"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=2345666s111777z
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 5);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        println!("tenpai wait tiles = {:?}", wait_tiles);
        // if 6s are a pair - then we have a 23456s sanmenchan -> wait for 147s
        // and if 6s are a triplet - then we have a 2345s nobetan -> wait for 25s
        assert!(wait_tiles_human_strs.contains(&String::from("1s")));
        assert!(wait_tiles_human_strs.contains(&String::from("4s")));
        assert!(wait_tiles_human_strs.contains(&String::from("7s")));
        assert!(wait_tiles_human_strs.contains(&String::from("2s")));
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q2() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 2:
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("5z"),
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("6z"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=6777788s555666z
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 4);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        println!("tenpai wait tiles = {:?}", wait_tiles);
        // if 8s are a pair - then we have a 67777s shape -> wait for 58s
        // and if 8s are separate, then they must match with the 7s: 678s|78s|77s -> wait for 69s
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
        assert!(wait_tiles_human_strs.contains(&String::from("8s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
        assert!(wait_tiles_human_strs.contains(&String::from("9s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q3() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 3:
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("3z"),
            tiles::Tile::from_string("3z"),
            tiles::Tile::from_string("3z"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=3334555678s333z
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 6);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        println!("tenpai wait tiles = {:?}", wait_tiles);
        // if 3s is triplet:
        //   then if 5s is triplet, the shape is 333s|4s|555s|678s -> tanki wait on 4s
        //   or if 5s is pair + single, the shape is 333s|555s|45678s -> sanmenchan wait on 369s
        // or if 3s is pair + single:
        //   then if 5s is triplet, the shape is 33s|34s|555s|678s -> ryanmen wait on 25s
        //   or if 5s is pair + single, the shape is 33s|55s|345s|678s -> shanpon wait on 35s
        assert!(wait_tiles_human_strs.contains(&String::from("4s")));
        assert!(wait_tiles_human_strs.contains(&String::from("3s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
        assert!(wait_tiles_human_strs.contains(&String::from("9s")));
        assert!(wait_tiles_human_strs.contains(&String::from("2s")));
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q4() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 4:
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("9s"),
            tiles::Tile::from_string("9s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=2345566778899s
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 4);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        println!("tenpai wait tiles = {:?}", wait_tiles);
        // if 9s is pair:
        //   then if 8s is pair -> shanpon wait 89s
        //   or if 8s is separate -> 23455s|678s|678s|99s -> 5s must be pair -> shanpon wait 59s
        // if 9s is separate -> 2345566|789|789 -> 5s or 6s must be pair -> shanpon wait 56s
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
        assert!(wait_tiles_human_strs.contains(&String::from("8s")));
        assert!(wait_tiles_human_strs.contains(&String::from("9s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q5() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 5:
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
            tiles::Tile::from_string("9s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // confirmed with a calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=2334455677789s
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        assert_eq!(wait_tiles.len(), 3);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        println!("tenpai wait tiles = {:?}", wait_tiles);
        // if 9s is tanki -> 234|345|567|778s|9s -> cannot make the others form complete groups
        // if 89s is penchan -> 23344556777|89s
        //   then if 7s is triplet (remaining must be complete groups) -> 23344556|777|89s -> cannot find a pair that doesn't leave another isolated group
        //   or if 7s is pair (remaining must be complete groups) -> 234|345|567|77|89s -> penchan wait on 7s
        // if 79s is kanchan (remaining 8s must be in a complete group) -> 23344557|678|79s ->  but then the last 7s is isolated
        // if 789s -> 2334455677|789s
        //   then if remaining 7s is pair -> 23344556|77|789
        //      if 6 is tanki -> 2|345|345|6|77|789
        //      if 56 is wait -> 234|345|56|77|789 -> ryanmen wait on 47s
        //      if 46 is wait -> 23|345|5|46|77|789
        //      if 456 -> 23345|456|77|789
        //         if 5 is tanki -> 2334|5|456|77|789
        //         if 45 is wait -> 233|45|456|77|789
        //         if 35 is wait -> 234|35|456|77|789 -> kanchan wait on 4s
        //         if 345 -> 23|345|456|77|789 -> ryanmen wait on 14s
        //   then if remaining 7s are separate -> 234|345|567|7|789 -> tanki wait on 7s
        //      or -> 23344|567|57|789 but then there's no pair
        // note: the 23344556 shape is like a 23456+345 (sanmenchan)
        assert!(wait_tiles_human_strs.contains(&String::from("1s")));
        assert!(wait_tiles_human_strs.contains(&String::from("4s")));
        assert!(wait_tiles_human_strs.contains(&String::from("7s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q6() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 6: 3334445555s666z
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("6z"),
            tiles::Tile::from_string("6z"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=3334445555s666z
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        println!("tenpai wait tiles = {:?}", wait_tiles);
        // note: the hand already uses four of the 5s tile, so it cannot wait on a fifth 5s tile
        assert_eq!(wait_tiles.len(), 4);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        // the 6z (green dragon) must be a triplet
        // if 5s is triplet: 3334445|555s
        //   345 -> 3344|345|555 -> shanpon on 34s
        //   45 -> 333|44|45|555 -> ryanmen on 36s
        //   35 -> 33|444|35|555 -> kanchan on 4s
        // if 5s is pair -> 33344455|55s
        //   345 -> 34|345|345|55s -> ryanmen on 25s (but 5s already used four times in the hand)
        //   45 -> 3344|345|45|55
        //   35 -> 344|345|35|55
        assert!(wait_tiles_human_strs.contains(&String::from("2s")));
        assert!(wait_tiles_human_strs.contains(&String::from("3s")));
        assert!(wait_tiles_human_strs.contains(&String::from("4s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q7() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 7: 2333344445678s
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=2333344445678s
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        println!("tenpai wait tiles = {:?}", wait_tiles);
        // note: the hand already uses four of the 3s and 4s tile, so it cannot wait on a fifth copy of either of those tiles
        assert_eq!(wait_tiles.len(), 6);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        // if the 8s is in complete sequence (678s) -> 2333344445|678
        // a) 5 is tanki: 233334444|5|678 -> 4 must form a complete group (otherwise not tenpai), form a 444s triplet + 234s sequence -> 234|333|444|5|678 -> the 5s tanki wait follows the suji due to the 234s and 678s sequences: tanki waits on 258s
        // b) 5 is sequence: 2333444|345|678 -> 4 could form a complete group (triplet or sequence), or an incomplete group:
        //   i) 4 is in 444s triplet: 2333|444|345|678 -> either 2|333 or 23|33 (can form incomplete group + pair or complete gruop) -> tanki on 2s or ryanmen on 14s (but all four copies of 4s are used)
        //   ii) 4 is in 44s pair: 23334|44|345|678 -> either 234|33 or
        //   iii) 4 is in 234s sequence: 3344|234|345|678 -> shanpon on 34s (but neither of these are real since all 4 copies are used)
        //   iv) 4 is in a 34s incomplete group: 23344|34|345|678 -> can't be tenpai in this grouping (need a complete group + pair)
        //   v) 4 is in a 24s incomplete group: 33344|24|345|678 -> kanchan on 3s (but all 4 copies are used)
        //   vi) 4 is a tanki: 233344|4|345|678 -> not tenpai (need 2 complete groups)
        // but if 8s is in incomplete group:
        // 23333444456|78 -> (need to form 3 complete groups and a pair) -> 23333444|456|78 -> either 4 is pair (233334|44 -> 234|333|44) or 4 is triplet (23333|444 -> not tenpai) -> ryanmen on 69s
        assert!(wait_tiles_human_strs.contains(&String::from("1s")));
        assert!(wait_tiles_human_strs.contains(&String::from("2s")));
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
        assert!(wait_tiles_human_strs.contains(&String::from("8s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
        assert!(wait_tiles_human_strs.contains(&String::from("9s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q8() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 8: 1233455566678s
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("1s"),
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=1233455566678s
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        println!("tenpai wait tiles = {:?}", wait_tiles);
        assert_eq!(wait_tiles.len(), 4);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        // from 1s , could be complete group or incomplete group:
        // a) 1s tanki -> forces remaining tiles to form 4 complete groups in order to get tenpai -> 1|234|355566678 -> not tenpai
        // b) 12s -> forces remaining tiles to form 3 complete groups and a pair in order to get tenpai -> 12|33|456|556678 or 12|345|35566678 -> not tenpai
        // c) 13s -> 13|23455566678 -> 13|234|555|66|678 or 13|234|55|566678 -> kanchan 2s
        // d) 123s -> 123|3455566678 ->
        // 3 could be any:
        // a) 3 is tanki: 123|3|456|556678 -> not tenpai
        // b) 34s -> 123|34|55566678 -> 123|34|55|566678 or 123|34|555|66|678 -> ryanmen 25s
        // c) 35s -> 123|35|45566678 -> 123|35|456|56678 -> not tenpai
        // d) 345s -> 123|345|5566678 ->
        // 5 could be any:
        // a) 5 is tanki -> 123|345|5|566678 -> not tenpai
        // b) 55s -> 123|345|55|66678 -> 123|345|55|666|78 or 123|345|55|66|678 -> ryanmen 69s or shanpon 56s
        // b) 56s -> 123|345|56|56678 -> not tenpai
        // c) 57s -> 123|345|57|56668 -> not tenpai
        // d) 567s -> 123|345|567|5668 -> not tenpai
        assert!(wait_tiles_human_strs.contains(&String::from("2s")));
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
        assert!(wait_tiles_human_strs.contains(&String::from("9s")));
    }

    #[test]
    fn test_tenpai_wait_tiles_sample_pro_test_q9() {
        // from https://mahjong-ny.com/features/sample-pro-test/
        // question 9: 2333344445566s
        let tenpai_tiles = Vec::from([
            tiles::Tile::from_string("1s"),
            tiles::Tile::from_string("2s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("3s"),
            tiles::Tile::from_string("4s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("5s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("6s"),
            tiles::Tile::from_string("7s"),
            tiles::Tile::from_string("8s"),
        ]);

        let tile_groups: Vec<tiles::TileGroup> = Vec::new();
        let tenpai_tile_groups = tenpai_grouping(&tenpai_tiles, &tile_groups);
        assert!(tenpai_tile_groups.is_some());

        // calculator: https://riichi.harphield.com/tools/hand-analyzer/?hand=1233455566678s
        let wait_tiles = get_all_tenpai_wait_tiles(&tenpai_tiles);
        println!("tenpai wait tiles = {:?}", wait_tiles);
        assert_eq!(wait_tiles.len(), 4);
        let wait_tiles_human_strs: Vec<String> =
            wait_tiles.iter().map(|tile| tile.to_string()).collect();
        // from 1s , could be complete group or incomplete group:
        // a) 1s tanki -> forces remaining tiles to form 4 complete groups in order to get tenpai -> 1|234|355566678 -> not tenpai
        // b) 12s -> forces remaining tiles to form 3 complete groups and a pair in order to get tenpai -> 12|33|456|556678 or 12|345|35566678 -> not tenpai
        // c) 13s -> 13|23455566678 -> 13|234|555|66|678 or 13|234|55|566678 -> kanchan 2s
        // d) 123s -> 123|3455566678 ->
        // 3 could be any:
        // a) 3 is tanki: 123|3|456|556678 -> not tenpai
        // b) 34s -> 123|34|55566678 -> 123|34|55|566678 or 123|34|555|66|678 -> ryanmen 25s
        // c) 35s -> 123|35|45566678 -> 123|35|456|56678 -> not tenpai
        // d) 345s -> 123|345|5566678 ->
        // 5 could be any:
        // a) 5 is tanki -> 123|345|5|566678 -> not tenpai
        // b) 55s -> 123|345|55|66678 -> 123|345|55|666|78 or 123|345|55|66|678 -> ryanmen 69s or shanpon 56s
        // b) 56s -> 123|345|56|56678 -> not tenpai
        // c) 57s -> 123|345|57|56668 -> not tenpai
        // d) 567s -> 123|345|567|5668 -> not tenpai
        assert!(wait_tiles_human_strs.contains(&String::from("2s")));
        assert!(wait_tiles_human_strs.contains(&String::from("5s")));
        assert!(wait_tiles_human_strs.contains(&String::from("6s")));
        assert!(wait_tiles_human_strs.contains(&String::from("9s")));
    }
}
